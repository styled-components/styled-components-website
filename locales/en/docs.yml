title: Documentation
description: Learn how to use styled-components and to style your apps without stress
about: |
  Utilising tagged template literals (a recent addition to JavaScript) and the power of CSS,
  styled-components allows you to write actual CSS code to style your components. It also removes
  the mapping between components and styles – using components as a low-level styling construct
  could not be easier!
basics: Basics
basicsDescription: Get Started with styled-components basics.
motivation: |
  ## Motivation

  This talk by Max Stoiber is a really thorough introduction to styled-components
  and goes through what the motivations behind its creation were, along with some
  other information to get started with.
advanced: Advanced
installation: |
  ## Installation

  Install styled-components from npm:

  ```
  npm install --save styled-components
  ```
gettingStarted: |
  ## Getting Started

  styled-components utilises tagged template literals to style your components.

  It removes the mapping between components and styles. This means that when you're defining your styles,
  you're actually creating a normal React component, that has your styles attached to it.

  This example creates two simple components, a wrapper and a title, with some styles attached to it.
  You can edit the code and get a feel for how you'd work with styled-components.

  ```react
  // Create a Title component that'll render an <h1> tag with some styles
  const Title = styled.h1`
    font-size: 1.5em;
    text-align: center;
    color: palevioletred;
  `;

  // Create a Wrapper component that'll render a <section> tag with some styles
  const Wrapper = styled.section`
    padding: 4em;
    background: papayawhip;
  `;

  // Use Title and Wrapper like any other React component – except they're styled!
  render(
    <Wrapper>
      <Title>
        Hello World, this is my first styled component!
      </Title>
    </Wrapper>
  );
  ```

  > The CSS rules are automatically vendor prefixed, so you don't have to think about it.
passedProps: |
  ## Passed props

  styled-components pass on all their props.

  This example shows how all props of the Input component are passed on to the
  DOM node that is mounted, as with React elements.

  ```react
  // Create an Input component that'll render an <input> tag with some styles
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  // Render a styled text input with a placeholder of "@mxstbr", and one with a value of "@geelen"
  render(
    <div>
      <Input placeholder="@mxstbr" type="text" />
      <Input value="@geelen" type="text" />
    </div>
  );
  ```
adaptingBasedOnProps: |
  ## Adapting based on props

  You can pass a function ("interpolations") to a styled component's template literal
  to adapt it based on its props.

  This button component has a primary state that changes its colour.
  When setting the <Code>primary</Code> prop to true, we are swapping out its background and text colour.

  ```react
  const Button = styled.button`
    /* Adapt the colours based on primary prop */
    background: ${props => props.primary ? 'palevioletred' : 'white'};
    color: ${props => props.primary ? 'white' : 'palevioletred'};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  render(
    <div>
      <Button>Normal</Button>
      <Button primary>Primary</Button>
    </div>
  );
  ```
stylingAnyComponents: |
  ## Styling any components

  The `styled` method works perfectly on all of your own or any third-party
  components as well, as long as they pass the `className` prop to their rendered sub-components,
  which should pass it too, and so on.
  Ultimately, the `className` must be passed down the line to an actual DOM node for the styling
  to take any effect.

  > If you are using `react-native` keep in mind to use `style` instead of `className`.

  If you're using any external library, you can consider using this pattern to turn them
  into styled components. The same pattern works for your own components as well, if you
  need some components to stay unstyled on their own.

  ```react
  // This could be react-router's Link for example
  const Link = ({ className, children }) => (
    <a className={className}>
      {children}
    </a>
  )

  const StyledLink = styled(Link)`
    color: palevioletred;
    font-weight: bold;
  `;

  render(
    <div>
      <Link>Unstyled, boring Link</Link>
      <br />
      <StyledLink>Styled, exciting Link</StyledLink>
    </div>
  );
  ```

  Consider carefully whether to wrap your own components in a styled component, when it isn't necessary.
  You will disable the automatic whitelisting of props, and reverse the recommended order of styled
  components and structural components.

  You can also pass tag names into the `styled()` factory call, like so: `styled('div')`.
  In fact, the `styled.tagname` helpers are just aliases that do the same.

  > styled-components always generates a real stylesheet with classes.
  > The classnames are then passed to the React component (including third party components)
  > via the `className` prop.
extendingStyles: |
  ## Extending Styles | v2

  Quite frequently you might want to use a component, but change it slightly for
  a single case. Now you could pass in an interpolated function and change them
  based on some props, but that's quite a lot of effort for overriding the styles
  once.

  To do this in an easier way you can call `extend` on the component
  to generate another. You style it like any other styled component.
  It overrides duplicate styles from the initial component and keeps the others around.

  Here we use the button from the last section and create a special one, extending it
  with some colour-related styling.

  ```react
  // The Button from the last section without the interpolations
  const Button = styled.button`
    color: palevioletred;
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  // We're extending Button with some extra styles
  const TomatoButton = Button.extend`
    color: tomato;
    border-color: tomato;
  `;

  render(
    <div>
      <Button>Normal Button</Button>
      <TomatoButton>Tomato Button</TomatoButton>
    </div>
  );
  ```

  We can see that the new `TomatoButton` still resembles `Button`, while we have only
  added two new rules.

  > You should only use `Comp.extend` if you know that `Comp` is a styled component.
  > If you're importing from another file or a third party library, prefer to use
  > `styled(Comp)` as it accomplishes the same thing but works with *any* React
  > component. Read more about [what the difference between `Comp.extend` and `styled(Comp)` is.](/docs/#what-is-the-difference-betweencompextendandstyled(comp)?)

  In really rare cases you might want to change which tag or component a styled component renders.
  For this case, we have an escape hatch. You can use the <Code>withComponent</Code> to extend
  the styles and use a different tag altogether.

  ```react
  const Button = styled.button`
    display: inline-block;
    color: palevioletred;
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  // We're replacing the <button> tag with an <a> tag, but reuse all the same styles
  const Link = Button.withComponent('a')

  // Use .withComponent together with .extend to both change the tag and use additional styles
  const TomatoLink = Link.extend`
    color: tomato;
    border-color: tomato;
  `;

  render(
    <div>
      <Button>Normal Button</Button>
      <Link>Normal Link</Link>
      <TomatoLink>Tomato Link</TomatoLink>
    </div>
  );
  ```
attachingAdditionalProps: |
  ## Attaching additional props | v2

  To avoid unnecessary wrappers that just pass on some props to the rendered component,
  or element, you can use the `.attrs` constructor. It allows you to attach
  additional props (or "attributes") to a component.

  This way you can for example attach static props to an element, or pass a third-party prop
  like `activeClassName` to React Router's Link component. Furthermore you can also
  attach more dynamic props to a component. The `.attrs` object also takes functions,
  that receive the props that the component receives. The return value will be merged into the
  resulting props as well.

  Here we render an `Input` component and attach some dynamic and static attributes
  to it:

  ```react
  const Input = styled.input.attrs({
    // we can define static props
    type: 'password',

    // or we can define dynamic ones
    margin: props => props.size || '1em',
    padding: props => props.size || '1em'
  })`
    color: palevioletred;
    font-size: 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;

    /* here we use the dynamically computed props */
    margin: ${props => props.margin};
    padding: ${props => props.padding};
  `;

  render(
    <div>
      <Input placeholder="A small text input" size="1em" />
      <br />
      <Input placeholder="A bigger text input" size="2em" />
    </div>
  );
  ```

  As you can see, we get access to our newly created props in the interpolations, and
  the `type` attribute is passed down to the element.
animations: |
  ## Animations

  CSS animations with `@keyframes` aren't scoped to a single component but you still don't want them
  to be global. This is why we export a `keyframes` helper which will generate a unique name for your
  keyframes. You can then use that unique name throughout your app.

  This way, you get all the benefits of using JavaScript, are avoiding name clashes and get your keyframes
  like always:

  ```react
  // keyframes returns a unique name based on a hash of the contents of the keyframes
  const rotate360 = keyframes`
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  `;

  // Here we create a component that will rotate everything we pass in over two seconds
  const Rotate = styled.div`
    display: inline-block;
    animation: ${rotate360} 2s linear infinite;
    padding: 2rem 1rem;
    font-size: 1.2rem;
  `;

  render(
    <Rotate>&lt; 💅 &gt;</Rotate>
  );
  ```
reactNative: |
  ## React Native

  styled-components can be used with React Native in the same way,
  except you import it from `styled-components/native` instead.

  ```jsx
  import React from 'react'
  import styled from 'styled-components/native';

  const StyledView = styled.View`
    background-color: papayawhip;
  `;

  const StyledText = styled.Text`
    color: palevioletred;
  `;

  class MyReactNativeComponent extends React.Component {
    render() {
      return (
        <StyledView>
          <StyledText>Hello World!</StyledText>
        </StyledView>
      )
    }
  }
  ```

  We also support more complex styles (like `transform`), which would normally be an array,
  and shorthands (e.g. for `margin`) thanks to `css-to-react-native`!

  Imagine how you'd write the property in React Native, guess how you'd transfer
  it to CSS, and you're probably right:

  ```jsx
  const RotatedBox = styled.View`
    transform: rotate(90deg);
    text-shadow-offset: 10px 5px;
    font-variant: small-caps;
    margin: 5px 7px 2px;
  `;
  ```

  Some of the differences to the web-version are, that you cannot use
  the `keyframes` and `injectGlobal` helpers since React Native doesn't
  support keyframes or global styles. We will also warn you if you use media queries or nest your CSS.

  > In v2 we support percentages. To make this possible we need to enforce units for all shorthands.
  > If you're migrating to v2,
  > [a codemod is available](https://github.com/styled-components/styled-components-native-code-mod).
advancedDescription: |
  Advanced usage of styled-components - Theming, refs, Security, Existing CSS, Media Templates,
  Tagged Template Literals, SSR
theming: |
  ## Theming

  styled-components has full theming support by exporting a `<ThemeProvider>` wrapper component.
  This component provides a theme to all React components underneath itself via the context API. In the render
  tree all styled-components will have access to the provided theme, even when they are multiple levels deep.

  To illustrate this, let's create our Button component, but this time we'll pass some variables down
  as a theme.

  ```react
  // Define our button, but with the use of props.theme this time
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Color the border and text with theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // We're passing a default theme for Buttons that aren't wrapped in the ThemeProvider
  Button.defaultProps = {
    theme: {
      main: 'palevioletred'
    }
  }

  // Define what props.theme will look like
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button>Normal</Button>

      <ThemeProvider theme={theme}>
        <Button>Themed</Button>
      </ThemeProvider>
    </div>
  );
  ```

  ### Function themes

  You can also pass a function for the theme prop. This function will receive the parent theme, that is from
  another `<ThemeProvider>` higher up the tree. This way themes themselves can be made contextual.

  This example renders our above themed Button and a second one that uses a second ThemeProvider to invert the
  background and foreground colours. The function `invertTheme` receives the upper theme and creates a new one.

  ```react
  // Define our button, but with the use of props.theme this time
  const Button = styled.button`
    color: ${props => props.theme.fg};
    border: 2px solid ${props => props.theme.fg};
    background: ${props => props.theme.bg};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;
  `;

  // Define our `fg` and `bg` on the theme
  const theme = {
    fg: 'palevioletred',
    bg: 'white'
  };

  // This theme swaps `fg` and `bg`
  const invertTheme = ({ fg, bg }) => ({
    fg: bg,
    bg: fg
  });

  render(
    <ThemeProvider theme={theme}>
      <div>
        <Button>Default Theme</Button>

        <ThemeProvider theme={invertTheme}>
          <Button>Inverted Theme</Button>
        </ThemeProvider>
      </div>
    </ThemeProvider>
  );
  ```

  ### Getting the theme without styled components

  If you ever need to use the current theme outside styled components (e.g. inside big components), you can use
  the `withTheme` higher order component.

  ```jsx
  import { withTheme } from 'styled-components'

  class MyComponent extends React.Component {
    render() {
      console.log('Current theme: ', this.props.theme);
      // ...
    }
  }

  export default withTheme(MyComponent)
  ```

  ### The `theme` prop

  A theme can also be passed down to a component using the `theme` prop.

  This is useful to circumvent a missing `ThemeProvider` or to override it.

  ```react
  // Define our button
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Color the border and text with theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Define what main theme will look like
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button theme={{ main: 'royalblue' }}>Ad hoc theme</Button>
      <ThemeProvider theme={theme}>
        <div>
          <Button>Themed</Button>
          <Button theme={{ main: 'darkorange' }}>Overidden</Button>
        </div>
      </ThemeProvider>
    </div>
  );
  ```
refs: |
  ## Refs

  Passing a `ref` prop to a styled component will give you an instance of
  the `StyledComponent` wrapper, but not to the underlying DOM node.
  This is due to how refs work.
  It's not possible to call DOM methods, like `focus`, on our wrappers directly.

  To get a ref to the actual, wrapped DOM node, pass the callback to the `innerRef` prop instead.

  > We don't support string refs (i.e. `innerRef="node"`), since they're already deprecated in React.

  This example uses `innerRef` to save a ref to the styled input and focuses it once the user
  hovers over it.

  ```react
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  class Form extends React.Component {
    render() {
      return (
        <Input
          placeholder="Hover here..."
          innerRef={x => { this.input = x }}
          onMouseEnter={() => this.input.focus()}
        />
      );
    }
  }

  render(
    <Form />
  );
  ```
security: |
  ## Security

  Since styled-components allows you to use arbitrary input as interpolations, you must be
  careful to sanitize that input. Using user input as styles can lead to any CSS being evaluated in the user's
  browser that an attacker can place in your application.

  This example shows how bad user input can even lead to API endpoints being called on a user's
  behalf.

  ```jsx
  // Oh no! The user has given us a bad URL!
  const userInput = '/api/withdraw-funds';

  const ArbitraryComponent = styled.div`
    background: url(${userInput});
    /* More styles here... */
  `;
  ```

  Be very careful! This is obviously a made-up example, but CSS injection can be unobvious and
  have bad repercussions. Some IE versions even execute arbitrary JavaScript within url declarations.

  There is an upcoming standard to sanitize CSS from JavaScript,
  [`CSS.escape`](https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).
  It's not very well supported across browsers yet, so we recommend using the
  [polyfill by Mathias Bynens](https://github.com/mathiasbynens/CSS.escape) in your app.
existingCSS: |
  ## Existing CSS

  There are a couple of implementation details that you should be aware of, if you choose to use
  styled-components together with existing CSS.

  styled-components generates an actual stylesheet with classes, and attaches those classes to
  the DOM nodes of styled components via the `className` prop.
  It injects the generated stylesheet at the end of the head of the document during runtime.

  ### Styling normal React components

  If you use the `styled(MyComponent)` notation and `MyComponent` does not
  render the passed-in `className` prop, then no styles will be applied.
  To avoid this issue, make sure your component attaches the passed-in className to a DOM node:

  ```jsx
  class MyComponent extends React.Component {
    render() {
      // Attach the passed-in className to the DOM node
      return <div className={this.props.className} />;
    }
  }
  ```

  If you have pre-existing styles with a class, you can combine the global class with the
  passed-in one:

  ```jsx
  class MyComponent extends React.Component {
    render() {
      // Attach the passed-in className to the DOM node
      return <div className={`some-global-class ${this.props.className}`} />;
    }
  }
  ```

  ### Issues with Specificity

  If you apply a global class together with a styled component class, the result might not be
  what you're expecting. If a property is defined in both classes with the same specificty,
  the last one will win.

  ```jsx
  // MyComponent.js
  const MyComponent = styled.div`background-color: green;`;

  // my-component.css
  .red-bg {
    background-color: red;
  }

  // For some reason this component still has a green background,
  // even though you're trying to override it with the "red-bg" class!
  <MyComponent className="red-bg" />
  ```

  In the above example the styled component class takes precendence over the global class, since
  styled-components injects its styles during runtime into the DOM at the end of the head.
  Thus its styles win over the other ones.

  Since it's often hard to control where your global CSS is injected into the DOM with tools like
  Webpack, the easiest thing is to bump up the specificity of your global class by repeating the
  classname:

  ```css
  /* my-component.css */
  .red-bg.red-bg {
    background-color: red;
  }
  ```
mediaTemplates: |
  ## Media Templates
  Media queries are an indispensable tool when developing responsive web apps.

  This is a very simple example. It shows a basic component changing its background colour,
  once the screen's width drops below a threshold of `700px`.

  ```react
  const Content = styled.div`
    background: papayawhip;
    height: 3em;
    width: 3em;

    @media (max-width: 700px) {
      background: palevioletred;
    }
  `;

  render(
    <Content />
  );
  ```

  Since media queries are long and are often repeated throughout an application, it can be
  useful to create a template for them.

  Due to the functional nature of JavaScript, you can easily define your own tagged template
  literal to wrap styles in media queries. Let's rewrite the last example to try just that out.

  ```react
  const sizes = {
    desktop: 992,
    tablet: 768,
    phone: 376
  }

  // Iterate through the sizes and create a media template
  const media = Object.keys(sizes).reduce((acc, label) => {
    acc[label] = (...args) => css`
      @media (max-width: ${sizes[label] / 16}em) {
        ${css(...args)}
      }
    `

    return acc
  }, {})

  const Content = styled.div`
    height: 3em;
    width: 3em;
    background: papayawhip;

    /* Now we have our methods on media and can use them instead of raw queries */
    ${media.desktop`background: dodgerblue;`}
    ${media.tablet`background: mediumseagreen;`}
    ${media.phone`background: palevioletred;`}
  `;

  render(
    <Content />
  );
  ```
taggedTemplateLiterals: |
  ## Tagged Template Literals

  Tagged Template Literals are a new feature in ES6. They let you define custom string interpolation rules,
  which is how we're able to create styled components.

  If you pass no interpolations, the first argument your function receives is an array with a string in it.

  ```jsx
  // These are equivalent:
  fn`some string here`;
  fn([ 'some string here' ]);
  ```

  Once you pass interpolations, the array contains the passed string, split at the positions of the
  interpolations. The rest of the arguments will be the interpolations, in order.

  ```jsx
  const aVar = 'good';

  // These are equivalent:
  fn`this is a ${aVar} day`;
  fn([ 'this is a ', ' day' ], aVar);
  ```

  This is a bit cumbersome to work with, but it means that we can receive variables, functions, or mixins
  (`css` helper) in styled components and can flatten that into pure CSS.

  If you want to learn more about tagged template literals, check out Max Stoiber's article:
  [The magic behind 💅 styled-components](https://mxstbr.blog/2016/11/styled-components-magic-explained/)
serverSideRendering: |
  ## Server Side Rendering | v2

  styled-components supports concurrent server side rendering, with stylesheet rehydration.
  The basic idea is that everytime you render your app on the server, you can create
  a `ServerStyleSheet` and add a provider to your React tree, that accepts styles
  via a context API.

  This doesn't interfere with global styles, such as `keyframes` or `injectGlobal` and
  allows you to use styled-components with React DOM's SSR, or even Rapscallion.

  The basic API goes as follows:

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(sheet.collectStyles(<YourApp />))
  const styleTags = sheet.getStyleTags() // or sheet.getStyleElement()
  ```

  The `collectStyles` method wraps your element in a provider. Optionally you can use
  the `StyleSheetManager` provider directly, instead of this method. Just make sure not to
  use it on the client-side.

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet, StyleSheetManager } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(
    <StyleSheetManager sheet={sheet.instance}>
      <YourApp />
    </StyleSheetManager>
  )

  const styleTags = sheet.getStyleTags() // or sheet.getStyleElement()
  ```

  The `sheet.getStyleTags()` returns a string of multiple `<style>` tags.
  You need to take this into account when adding the CSS string to your HTML output.

  Alternatively the `ServerStyleSheet` instance also has a `getStyleElement()` method
  that returns an array of React elements.

  ### Next.js

  In Next.js, you will need to structure your `_document.js` file differently, than
  the provided example in their repository for v1.

  ```jsx
  import Document, { Head, Main, NextScript } from 'next/document'
  import { ServerStyleSheet } from 'styled-components'

  export default class MyDocument extends Document {
    static getInitialProps ({ renderPage }) {
      const sheet = new ServerStyleSheet()
      const page = renderPage(App => props => sheet.collectStyles(<App {...props} />))
      const styleTags = sheet.getStyleElement()
      return {
        ...page,
        styleTags
      }
    }

    render() {
      return (
        <html>
          <Head>
            {/* ... */}

            {this.props.styleTags}
          </Head>
          <body>
            <Main />
            <NextScript />
          </body>
        </html>
      )
    }
  }
  ```

  You will need to use `babel-plugin-styled-components` to get this working.
  More details [here](https://www.npmjs.com/package/babel-plugin-styled-components)

  Refer to [our example](https://github.com/zeit/next.js/tree/master/examples/with-styled-components)
  in the Next.js repo from an up-to-date usage example.
