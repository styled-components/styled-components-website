title: Documentaci√≥n
description: Aprende como usar styled-components y a estilizar tus apps sin estr√©s
about: |
  Usando "tagged template literals" (una nueva caracter√≠stica en JavaScript) y el poder de CSS,
  styled-components permite utilizar c√≥digo CSS real para estilizar tus componentes.
  Adem√°s provee el mapeo dentro componentes y estilos - ¬°No podr√≠a ser m√°s f√°cil utilizar componentes
  como un estructrura de estilo de bajo nivel!
basicsTitle: Bases
basicsDescription: Comenzando con las bases de styled-components.
motivation: |
  ## Motivaci√≥n

  Esta charla por Max Stoiber es una introduci√≥n muy detallada a styled-components
  y habla acerca de las motivaciones detr√°s de su creac√≥n, junto con informaci√≥n de como empezar.
advanced: Avanzado
installation: |
  ## Instalaci√≥n

  Instala styled-components desde npm:

  ```
  npm install --save styled-components
  ```
gettingStarted: |
  ## Comenzando

  styled-components utiliza "tagged template literals" para estilizar tus componentes.

  Remueve el mapeo entre componentes y estilos. Esto significa que cuando defines tus estilos,
  est√°s de hecho creando un componente normal de React, el cual tiene tus estilos adjuntados a s√≠ mismo.

  Este ejemplo crea dos componentes simples, una envoltura y un t√≠tulo, con algunos estilos adjuntados.
  Puedes editar el c√≥digo y tener una sensaci√≥n de como es trabajar con styled-components.

  ```react
  // Crea el componente T√≠tulo, el cual renderiza una etiqueta <h1> con algunos estilos
  const Title = styled.h1`
    font-size: 1.5em;
    text-align: center;
    color: palevioletred;
  `;

  // Crea la componente envoltura, el cual renderiza una etiqueta <section> con algunos estilos
  const Wrapper = styled.section`
    padding: 4em;
    background: papayawhip;
  `;

  // Usa el t√≠tulo y envoltura como cualquier otro componente de React - ¬°Excepto que est√°n estilizados!
  render(
    <Wrapper>
      <Title>
        ¬°Hola mundo, √©ste es mi primer "styled-component"!
      </Title>
    </Wrapper>
  );
  ```

  > Las reglas de CSS autom√°ticamente a√±aden el prefijo espec√≠fico del navegador,
  > as√≠ que no tienes que pensar en ello.
passedProps: |
  ## "Props" enviadas

  styled-components pasan hac√≠a abajo todas sus "props".

  Este ejemplo muestra como todas las "props" del componente Input se pasan al nodo de DOM que est√°
  montado, como con los elementos de React.

  ```react
  // Crea un componente "Input" que renderizar√° una etiqueta <input> con algunos estilos
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  // Renderiza un "input" de texto estilizado con un "placeholder" de "@mxstbr", y otro con valor de "geelen"
  render(
    <div>
      <Input placeholder="@mxstbr" type="text" />
      <Input value="@geelen" type="text" />
    </div>
  );
  ```
adaptingBasedOnProps: |
  ## Adaptaci√≥n basada en "props"

  Puedes pasar una funci√≥n ("interpolaci√≥n") a la plantilla del "styled-component" para
  adaptarlo bas√°ndose en sus "props".

  Este componente bot√≥n tiene un estado primario el cual cambia su color.
  Cuando se ajusta el prop como true <Code>primario</Code>, estamos intercambiando el color de fondo
  y el color de texto.

  ```react
  const Button = styled.button`
    /* Adapta los colores basado en el "prop" primario */
    background: ${props => props.primario ? 'palevioletred' : 'white'};
    color: ${props => props.primario ? 'white' : 'palevioletred'};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  render(
    <div>
      <Button>Normal</Button>
      <Button primario>Primario</Button>
    </div>
  );
  ```
stylingAnyComponents: |
  ## Estilizando cualquier componente

  El m√©todo `styled` funciona perfectamente en todos tus componentes y tambi√©n en componentes de terceros,
  siempre y cuando pasen la "prop" `className` a sus sub componentes renderizados.
  Finalmente, la `className` debe ser pasada hasta alcanzar el nodo DOM para que el estilizado
  tenga cualquier efecto.

  > S√≠ est√°s usando `react-native` ten en cuenta usar `style` en lugar de `className`.

  S√≠ est√°s utilizando cualquier librer√≠a externa, considera usar este patr√≥n para convertirlos en
  styled-components. El mismo patr√≥n funciona con tus propios componentes tambi√©n, s√≠ necesitas
  que alg√∫n componente se mantenga sin estilo por s√≠ mismo.

  ```react
  // Esto puede ser el Link de react-router por ejemplo
  const Link = ({ className, children }) => (
    <a className={className}>
      {children}
    </a>
  )

  const StyledLink = styled(Link)`
    color: palevioletred;
    font-weight: bold;
  `;

  render(
    <div>
      <Link>Link sin estilo, aburrido</Link>
      <br />
      <StyledLink>Link emocionante, estilizado</StyledLink>
    </div>
  );
  ```

  Considera cuidadosamente envolver tus componentes en un "styled-component", cuando no es necesario,
  deshabilitar√°s el "whitelisting" autom√°tico de "props", y revertir√°s el orden recomendado de
  styled-components y componentes estructurales.

  Tambi√©n puedes pasar nombres de etiquetas a la f√°brica `styled()` en su llamada, por ejemplo: `styled('div')`.
  De hecho, los ayudantes `styled.etiqueta` son s√≥lo alias que hacen lo mismo.

  > styled-components siempre genera una hoja de estilos real con clases.
  > Los nombres de clase son pasados al componente de React (incluyendo componentes de terceros)
  > A trav√©s del "prop" `className`
extendingStyles: |
  ## Extendiendo estilos | v2

  Frecuentemente te gustar√≠a usar un componente, y cambiarlo ligeramente en un s√≥lo caso.
  Puedes pasar una funci√≥n  interpolada y cambiarlo basado en algunos "props", pero eso
  es mucho esfuerzo para sobreescribir los estilos una sola vez.

  Para hacer esto m√°s facilmente, puedes llamar `extend` en el componente para generar otro nuevo.
  Lo estilizas como cualquier otro componente y √©ste sobreescribe los estilos duplicados del
  componente original y mantiene los nuevos.

  Aqu√≠ uamos un bot√≥n de la √∫ltima secci√≥n y creamos uno especial, extendi√©ndolo con unos estilos
  relativos a su color.

  ```react
  // El bot√≥n de la √∫ltima secci√≥n sin interpolaciones
  const Button = styled.button`
    color: palevioletred;
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  // Estamos extendiendo el bot√≥n con unos estilos extra
  const TomatoButton = Button.extend`
    color: tomato;
    border-color: tomato;
  `;

  render(
    <div>
      <Button>Bot√≥n normal</Button>
      <TomatoButton>Bot√≥n tomate</TomatoButton>
    </div>
  );
  ```

  Podemos ver que el nuevo `TomatoButton` a√∫n se asemeja a `Button`, cu√°ndo s√≥lo le a√±adimos dos
  reglas nuevas.

  > S√≥lo debes usar `Comp.estend` s√≠ sabes que ese `Comp` es un "styled-component".
  > Si est√°s importando de otro archivo o librer√≠a de terceros, es mejor que uses
  > `styled(Comp)` ya que logra el mismo resultado, pero functiona con *cualquier* componente de
  > React. Lee m√°s acerca de [las diferencias entre `Comp.extend` y `styled(Comp)`](/es/docs/#)

  En los muy raros casos que quieras cambiar que etiqueta o componente renderiza el "styled-component".
  Tenemos una manera de solucionarlo. Puedes usar el <Code>withComponent</Code> para extender los
  estilos y usar una etiqueta completamente diferente.

  ```react
  const Button = styled.button`
    display: inline-block;
    color: palevioletred;
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  // Estamos reemplazando la etiqueta <button> con una etiqueta <a>, pero reusamos todos los estilos
  const Link = Button.withComponent('a')

  // Usa `.withComponent` junto a `.extend` para cambiar la etiqueta y usar estilos adicionales
  const TomatoLink = Link.extend`
    color: tomato;
    border-color: tomato;
  `;

  render(
    <div>
      <Button>Normal Button</Button>
      <Link>Normal Link</Link>
      <TomatoLink>Tomato Link</TomatoLink>
    </div>
  );
  ```
attachingAdditionalProps: |
  ## Adjuntando "props" adicionales | v2

  Para evitar envolturas innecesarias que s√≥lo pasan algunos "props" al componente renderizado,
  o elemento, puedes usar el constructor `.attrs`. √âste te permite adjuntar "props" adicionales
  (o atributos) a un componente. Adem√°s, puedes a√±adir m√°s "props" din√°micos a un componente. El
  objeto `.attrs` tambi√©n recive funciones, que reciben "props" que el componente recibe. El valor
  de resultado se combinar√° a los "props" resultantes tambi√©n.

  Aqu√≠ renderizamos un componente `Input` y le adjuntamos algunos atributos est√°ticos y din√°micos:

  ```react
  const Input = styled.input.attrs({
    // Podemos definir "props" est√°ticos
    type: 'password',

    // o podemos definirlos din√°micos
    margin: props => props.size || '1em',
    padding: props => props.size || '1em'
  })`
    color: palevioletred;
    font-size: 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;

    /* aqu√≠ usamos "props" calculados dinamicamente */
    margin: ${props => props.margin};
    padding: ${props => props.padding};
  `;

  render(
    <div>
      <Input placeholder="un input de texto peque√±o" size="1em" />
      <br />
      <Input placeholder="un input de texto m√°s grande" size="2em" />
    </div>
  );
  ```

  Como puedes ver, tenemos acceso a nuestros nuevos "props" creados en las interpolaciones, y el
  atributo `type` es pasado hacia abajo al elemento.
animations: |
  ## Animaciones

  Las animaciones de CSS con `@keyframes` no tienen alcance s√≥lo para un componente, pero a√∫n as√≠,
  no quieres tenerlos de manera global. Es por eso que exportamos un ayudante `keyframes` el cual
  genera un nombre √∫nico para tus "keyframes". Puedes usar el nombre √∫nico en toda tu app.

  De esta manera, tienes todos los beneficios de usar JavaScript, evitando conflicto de nombres y
  tener tus "keyframes" como siempre:

  ```react
  // keyframes retorna un nombre √∫nico basado en los contenidos de los "keyframes"
  const rotate360 = keyframes`
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  `;

  // Aqu√≠ creamos un componente que girar√° todo lo que pasemos en dos segundos
  const Rotate = styled.div`
    display: inline-block;
    animation: ${rotate360} 2s linear infinite;
    padding: 2rem 1rem;
    font-size: 1.2rem;
  `;

  render(
    <Rotate>&lt; üíÖ &gt;</Rotate>
  );
  ```
reactNative: |
  ## React Native

  styled-components puede usarse con "React Native" en la misma manera,
  excepto que necesitas importarlo de `styled-components/native`.

  ```jsx
  import React from 'react'
  import styled from 'styled-components/native';

  const StyledView = styled.View`
    background-color: papayawhip;
  `;

  const StyledText = styled.Text`
    color: palevioletred;
  `;

  class MyReactNativeComponent extends React.Component {
    render() {
      return (
        <StyledView>
          <StyledText>¬°Hola Mundo!</StyledText>
        </StyledView>
      )
    }
  }
  ```

  Tambi√©n soportamos estilos m√°s complejos (como `transform`), los cuales, normalmente ser√≠an un arreglo,
  (por ejemplo para `margin`) ¬°Gracias a `css-to-react-native`!

  Imagina como escribir√≠as una propiedad en React Native, adivina como lo transferir√≠as a CSS,
  y posiblemente est√©s en lo correcto:

  ```jsx
  const RotatedBox = styled.View`
    transform: rotate(90deg);
    text-shadow-offset: 10px 5px;
    font-variant: small-caps;
    margin: 5px 7px 2px;
  `;
  ```

  Algunas de las diferencias con la versi√≥n web, son que no puedes usar los ayudantes `keyframes` e
  `injectGlobal` ya que React Native no soporta "keyframes" o estilos globales.Tambi√©n te advertimos
  si usas "media queries" o CSS anidado.

  > En la v2 soportamos porcentajes. Para hacerlo posible necesitamos forzar las unidades en todas
  > las abreviaciones. Si est√°s migrando a la v2,
  > [Hay un ejemplo en codemod](https://github.com/styled-components/styled-components-native-code-mod).
advancedDescription: |
  Uso avanzado de styled-components - Tematizaci√≥n, refs, seguridad, CSS existente, Media Templates,
  Tagged Template Literals, SSR
theming: |
  ## Tematizaci√≥n

  styled-components tiene soporte completo para tematizaci√≥n exportando un componente `<ThemeProvider>`.
  √âste componente provee un tema a todos los componentes de React debajo de √©l via el API de contexto.
  en el √°rbol de renderizado todos los "styled-components" tendr√°n acceso al tema provisto, incluso
  cuando est√°n a varios niveles de profundidad.

  Para ilustrar mejor esto, vamos a crear nuestro componente Bot√≥n, pero √©sta vez pasaremos algunas
  variables como un tema.

  ```react
  // Definimos nuestro bot√≥, pero usando props.theme √©sta vez
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Colorea el borde y texto con theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Estamos pasando el tema por default para botones que no est√°n envueltos por un "ThemeProvider"
  Button.defaultProps = {
    theme: {
      main: 'palevioletred'
    }
  }

  // Definimos c√≥mo lucir√° props.theme
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button>Normal</Button>

      <ThemeProvider theme={theme}>
        <Button>Tematizado</Button>
      </ThemeProvider>
    </div>
  );
  ```

  ### Funciones de temas

  Tambi√©n puedes pasar una funci√≥n para "prop" de tema. √âsta funci√≥m recivir√° el tema padre, enviado
  por otro `<ThemeProvider>` m√°s arriba en el √°rbol. De √©sta manera, los temas pueden hacerse contextuales.

  Este ejemplo renderiza nuestro tema bot√≥n tematizado y un segundo que isa un segundo ThemeProvider
  que invierte el color de fondo. La funci√≥n `invertTheme` (Invertir tema) recive el tema superior y
  crea uno nuevo.

  ```react
  // Definimos nuestro bot√≥n, pro con el uso de props.theme √©sta vez
  const Button = styled.button`
    color: ${props => props.theme.fg};
    border: 2px solid ${props => props.theme.fg};
    background: ${props => props.theme.bg};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;
  `;

  // Definimos nuestro `fg` y `bg` en el tema
  const theme = {
    fg: 'palevioletred',
    bg: 'white'
  };

  // √âste tema invierte `fg` y `bg`
  const invertTheme = ({ fg, bg }) => ({
    fg: bg,
    bg: fg
  });

  render(
    <ThemeProvider theme={theme}>
      <div>
        <Button>Tema por default</Button>

        <ThemeProvider theme={invertTheme}>
          <Button>Tema invertido</Button>
        </ThemeProvider>
      </div>
    </ThemeProvider>
  );
  ```

  ### Comenzando con el tema sin "styled-components"

  S√≠ alguna vez necesitas usar el tema actual fuera de "styled-components" (por ejemplo, dentro de
  componentes muy grandes), puedes usar el componente de alto √≥rden `withTheme`.

  ```jsx
  import { withTheme } from 'styled-components'

  class MyComponent extends React.Component {
    render() {
      console.log('Tema actual: ', this.props.theme);
      // ...
    }
  }

  export default withTheme(MyComponent)
  ```

  ### la propiedad `theme`

  Un tema puede ser pasado hac√≠a abajo a un componente usando el "prop" `theme`.

  Esto es √∫til para burlar a un `ThemeProvider` ausente o sobreescribirlo.

  ```react
  // Definimos nuestro bot√≥n
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Colorea el borde y texto con theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Definimos como el tema principal lucir√°
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button theme={{ main: 'royalblue' }}>Tema ad hoc</Button>
      <ThemeProvider theme={theme}>
        <div>
          <Button>Tematizado</Button>
          <Button theme={{ main: 'darkorange' }}>Sobreescrito</Button>
        </div>
      </ThemeProvider>
    </div>
  );
  ```
refs: |
  ## Refs

  Pasando un "prop" `ref` a un "styled-component" te dar√° una instancia de una envoltura `StyledComponent`,
  pero no el elemento DOM subyacente.
  Esto es debido a como "refs" funciona.
  No es posible utilizar m√©todos de DOM como `focus` en nuestros componentes directamente.

  Para obtener un "ref" con el nodo DOM envuelto, pasa una funci√≥n "callback" al "prop" `innerRef`.

  > No soportamos refs como cadena (por ejemplo, `innerRef="node"`), ya que est√°n obsoletos en React.

  Este ejemplo utiliza `innerRef` para guardar la referencia al input estilizado y lo enfoca una vez
  que el usuario pasa el rat√≥n sobre √©l.

  ```react
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  class Form extends React.Component {
    render() {
      return (
        <Input
          placeholder="Pasa el rat√≥n por aqu√≠..."
          innerRef={x => { this.input = x }}
          onMouseEnter={() => this.input.focus()}
        />
      );
    }
  }

  render(
    <Form />
  );
  ```
security: |
  ## Seguridad

  Ya que "styled-components" te permite usar entradas arbitriarias como interpolaciones, debes de
  ser cuidadoso de como limpiar esa entrada. Usando entradas de usuario como estilos, puede llevar
  a que cualquier CSS se eval√∫e en el navegador del usuario que un agresor puede poner en tu aplicaci√≥n.

  Este ejemplo muestra como una mala entrada de usuario puede llevar a llamadas a APIs en nombre del
  usuario.

  ```jsx
  // ¬°Oh no, el usuario ha dado una mala URL!
  const userInput = '/api/retirar-fondos';

  const ArbitraryComponent = styled.div`
    background: url(${userInput});
    /* M√°s estilos aqu√≠... */
  `;
  ```

  ¬°Ten mucho cuidado! √âsto es obvuamente un ejemplo inventado, pero la inyecci√≥n de CSS puede no ser
  nada obvia y puede tener malas repercuciones. Algunas versiones de IE incluso pueden ejecutar
  JavaScript arbitriario dentro de la declaraci√≥n de url.

  Hay un est√°ndar de como limpiar CSS dentro de JavaScript,
  [`CSS.escape`](https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).
  No est√° muy bien soportado a trav√©s de los exploradores a√∫n, as√≠ que recomendamos tambi√©n utilizar el
  [polyfill por Mathias Bynens](https://github.com/mathiasbynens/CSS.escape) en tu app.
existingCSS: |
  ## CSS existente

  Hay ciertos detalles de implementaci√≥n de los cuales necesitas estar consciente, si eliges usar
  styled-components junto a CSS existente.

  styled-components genera una hoja de estilos con clases y adjunta esas clases a los nodos de
  DOM del "styled-component" a trav√©s del "prop" `className`.
  Inyecta la hoja de estilos generada al final del `head` del documento durante ejecuci√≥n.

  ### Estilizando componentes de React normales

  S√≠ usas la notaci√≥n `styled(MiComponente)` y `MiComponente` no renderiza el `className` enviado,
  entonces ning√∫n estilo se ha aplicado. Para evitar este problema, asegurate que tu componente
  adjunte el `className` enviado al nodo de DOM:

  ```jsx
  class MiComponente extends React.Component {
    render() {
      // Adjunta el `className` enviado al nodo de DOM
      return <div className={this.props.className} />;
    }
  }
  ```

  Si tienes algunos estilos preexistentes con una clase, puedes combinar la clase global con la
  enviada:

  ```jsx
  class MiComponente extends React.Component {
    render() {
      // Adjunta el `className` enviado al nodo de DOM
      return <div className={`alguna-clase-global ${this.props.className}`} />;
    }
  }
  ```

  ### Problemas con la especificidad

  Si aplicas una clase global junto a una clase de "styled-component", el resultado puede que no
  sea lo que est√°s esperando. Si una propiedad est√° definida en ambas clases con la misma
  especificidad, la √∫ltima es la que se aplicar√°.

  ```jsx
  // MiComponente.js
  const MiComponente = styled.div`background-color: green;`;

  // mi-componente.css
  .bg-rojo {
    background-color: red;
  }

  // Por alguna raz√≥n este componente a√∫n tendr√° el fondo color verde,
  // ¬°Incluso cuando est√°s tratando de sobreescribirlo con la clase "bg-rojo"!
  <MiComponente className="bg-rojo" />
  ```

  En el ejemplo de arriba, la clase del "styled-component" tiene precedencia sobre la clase global,
  ya que styled-components inyecta sus estilos durante ejecuci√≥n dentro del DOM al final del head.
  Por lo tanto, sus estilos ganan sobre otros.

  Ya que es dif√≠cil controlar donde tu CSS global es inyectado al DOM con herramientas como Webpack,
  la manera m√°s sencilla de subir la especificidad de tu clase global repitiendo el nombre de clase:

  ```css
  /* mi-componente.css */
  .bg-rojo.bg-rojo {
    background-color: red;
  }
  ```
mediaTemplates: |
  ## Media Templates

  Los "Media queries" son una herramienta indispensable cuando se desarrollan aplicaciones web
  responsivas.

  Este es un ejemplo muy simple. Muestra a un componente b√°sico cambiando su color de fondo, una
  vez que el ancho de la pantalla es menor al l√≠mite de `700px`.

  ```react
  const Content = styled.div`
    background: papayawhip;
    height: 3em;
    width: 3em;

    @media (max-width: 700px) {
      background: palevioletred;
    }
  `;

  render(
    <Content />
  );
  ```

  Ya que los "media queries" son largos y muchas veces repetidos a trav√©s de las aplicaciones, es
  √∫til crear un componente para ellos.

  Debido a la naturaleza funcional de JavaScript, puedes facilmente definir tu propio "template literal"
  para cambiar estilos dentro de "media queries". Reescribamos el √∫ltimo ejemplo para probar justo eso.

  ```react
  const sizes = {
    desktop: 992,
    tablet: 768,
    phone: 376
  }

  // Iterar a trav√©s de los tama√±os y crear un "media template"
  const media = Object.keys(sizes).reduce((acc, label) => {
    acc[label] = (...args) => css`
      @media (max-width: ${sizes[label] / 16}em) {
        ${css(...args)}
      }
    `

    return acc
  }, {})

  const Content = styled.div`
    height: 3em;
    width: 3em;
    background: papayawhip;

    /* Ahora tenemos nuestros m√©todos de media y podemos usarlos en vez de utilizarlos directamente */
    ${media.desktop`background: dodgerblue;`}
    ${media.tablet`background: mediumseagreen;`}
    ${media.phone`background: palevioletred;`}
  `;

  render(
    <Content />
  );
  ```
taggedTemplateLiterals: |
  ## Tagged Template Literals

  Las "tagged template literals" son una caracter√≠stica nueva en ES6. Te permiten definir reglas
  customizadas de interpolaci√≥n. Que es como somos capaces de crear "styled-components".

  Si no pasas interpolaciones, el primer argumento de tu funci√≥n, recibe un arreglo con la cadena en √©l.

  ```jsx
  // Estos son equivalentes:
  fn`una cadena aqu√≠`;
  fn([ 'una cadena aqu√≠' ]);
  ```

  Una vez que pases las interpolaciones, el arreglo contiene la cadena enviada, separada en las
  posiciones de las interpolaciones. El resto de los argumentos ser√°n las interpolaciones en √≥rden.

  ```jsx
  const aVar = 'buen';

  // √âstos son equivalentes:
  fn`este es un ${aVar} d√≠a`;
  fn([ 'este es un ', ' d√≠a' ], aVar);
  ```

  Esto es un poco engorroso para trabajar, pero significa que podemos recibir variables, funciones, o
  mixins (ayudante de `css`) en los "styled components" y se puede convertir a CSS puro.

  Si quieres aprender m√°s sobre "tagged template literals", revisa el art√≠culo de Max Stoiber:
  [The magic behind üíÖ styled-components](https://mxstbr.blog/2016/11/styled-components-magic-explained/)
serverSideRendering: |
  ## Renderizado del lado del servidor | v2

  styled-components soporta renderizado del lado del servidor de manera concurrente, con rehidrataci√≥n
  de hojas de estilo. La idea b√°sica es que cada vez que renderices tu app en el servidor, puedes
  crear un `ServerStyleSheet` y a√±adirlo a un "provider" en tu √°rbol de React, esto acepta estilos
  via el API de contexto.

  Esto no interfiere con los estilos globales. como por ejemplo `keyframes` o `injectGlobal` adem√°s
  te permite usar styled-components con el SSR de React DOM o incluso Rapscallion.

  El API b√°sico va de la siguiente manera:

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(sheet.collectStyles(<TuApp />))
  const styleTags = sheet.getStyleTags() // o sheet.getStyleElement()
  ```

  El m√©todo `collectStyles` envuelve tu elemento en un proveedor. Opcionalmente puedes usar el
  proveedor `StyleSheetManager` directamente, en vez de √©ste m√©todo. Tan s√≥lo asegurate de no usarlo
  en el lado del cliente.

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet, StyleSheetManager } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(
    <StyleSheetManager sheet={sheet.instance}>
      <TuApp />
    </StyleSheetManager>
  )

  const styleTags = sheet.getStyleTags() // o sheet.getStyleElement()
  ```

  `sheet.getStyleTags()` retorna una cadena de m√∫ltiples etiquetas `<style>`.
  Necesitas tomar esto en cuenta cuando a√±adas la cadena de CSS a tu salida de HTML.

  Alternativamente la instancia de `ServerStyleSheet` tambi√©n tiene un m√©todo `getStyleElement()`
  que retorna un arreglo de elementos de React.

  ### Next.js

  En Next.js, necesitar√°s estructurar tu archivo `_document.js` de manera diferente, que la que se
  provee en su ejemplo de su repositorio para la versi√≥n 1.

  ```jsx
  import Document, { Head, Main, NextScript } from 'next/document'
  import { ServerStyleSheet } from 'styled-components'

  export default class MyDocument extends Document {
    static getInitialProps ({ renderPage }) {
      const sheet = new ServerStyleSheet()
      const page = renderPage(App => props => sheet.collectStyles(<App {...props} />))
      const styleTags = sheet.getStyleElement()
      return {
        ...page,
        styleTags
      }
    }

    render() {
      return (
        <html>
          <Head>
            {/* ... */}

            {this.props.styleTags}
          </Head>
          <body>
            <Main />
            <NextScript />
          </body>
        </html>
      )
    }
  }
  ```

  Necesitar√°s usar `babel-plugin-styled-components` para que esto funcione.
  M√°s detalles [aqu√≠](https://www.npmjs.com/package/babel-plugin-styled-components)

  Refi√©rete a [nuestro ejemplo](https://github.com/zeit/next.js/tree/master/examples/with-styled-components)
  en el repositorio de Next.js de un ejemplo de uso actualizado.
