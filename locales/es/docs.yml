title: Documentación
description: Aprende como usar styled-components y a estilizar tus apps sin estrés
about: |
  Usando "tagged template literals" (una nueva característica en JavaScript) y el poder de CSS,
  styled-components permite utilizar código CSS real para estilizar tus componentes.
  Además provee el mapeo dentro componentes y estilos - ¡No podría ser más fácil utilizar componentes
  como un estructrura de estilo de bajo nivel!
basicsTitle: Bases
basicsDescription: Comenzando con las bases de styled-components.
motivation: |
  ## Motivación

  Esta charla por Max Stoiber es una introdución muy detallada a styled-components
  y habla acerca de las motivaciones detrás de su creacón, junto con información de como empezar.
advanced: Avanzado
installation: |
  ## Instalación

  Instala styled-components desde npm:

  ```
  npm install --save styled-components
  ```
gettingStarted: |
  ## Comenzando

  styled-components utiliza "tagged template literals" para estilizar tus componentes.

  Remueve el mapeo entre componentes y estilos. Esto significa que cuando defines tus estilos,
  estás de hecho creando un componente normal de React, el cual tiene tus estilos adjuntados a sí mismo.

  Este ejemplo crea dos componentes simples, una envoltura y un título, con algunos estilos adjuntados.
  Puedes editar el código y tener una sensación de como es trabajar con styled-components.

  ```react
  // Crea el componente Título, el cual renderiza una etiqueta <h1> con algunos estilos
  const Title = styled.h1`
    font-size: 1.5em;
    text-align: center;
    color: palevioletred;
  `;

  // Crea la componente envoltura, el cual renderiza una etiqueta <section> con algunos estilos
  const Wrapper = styled.section`
    padding: 4em;
    background: papayawhip;
  `;

  // Usa el título y envoltura como cualquier otro componente de React - ¡Excepto que están estilizados!
  render(
    <Wrapper>
      <Title>
        ¡Hola mundo, éste es mi primer "styled-component"!
      </Title>
    </Wrapper>
  );
  ```

  > Las reglas de CSS automáticamente añaden el prefijo específico del navegador,
  > así que no tienes que pensar en ello.
passedProps: |
  ## "Props" enviadas

  styled-components pasan hacía abajo todas sus "props".

  Este ejemplo muestra como todas las "props" del componente Input se pasan al nodo de DOM que está
  montado, como con los elementos de React.

  ```react
  // Crea un componente "Input" que renderizará una etiqueta <input> con algunos estilos
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  // Renderiza un "input" de texto estilizado con un "placeholder" de "@mxstbr", y otro con valor de "geelen"
  render(
    <div>
      <Input placeholder="@mxstbr" type="text" />
      <Input value="@geelen" type="text" />
    </div>
  );
  ```
adaptingBasedOnProps: |
  ## Adaptación basada en "props"

  Puedes pasar una función ("interpolación") a la plantilla del "styled-component" para
  adaptarlo basándose en sus "props".

  Este componente botón tiene un estado primario el cual cambia su color.
  Cuando se ajusta el prop como true <Code>primario</Code>, estamos intercambiando el color de fondo
  y el color de texto.

  ```react
  const Button = styled.button`
    /* Adapta los colores basado en el "prop" primario */
    background: ${props => props.primario ? 'palevioletred' : 'white'};
    color: ${props => props.primario ? 'white' : 'palevioletred'};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  render(
    <div>
      <Button>Normal</Button>
      <Button primario>Primario</Button>
    </div>
  );
  ```
stylingAnyComponents: |
  ## Estilizando cualquier componente

  El método `styled` funciona perfectamente en todos tus componentes y también en componentes de terceros,
  siempre y cuando pasen la "prop" `className` a sus sub componentes renderizados.
  Finalmente, la `className` debe ser pasada hasta alcanzar el nodo DOM para que el estilizado
  tenga cualquier efecto.

  > Sí estás usando `react-native` ten en cuenta usar `style` en lugar de `className`.

  Sí estás utilizando cualquier librería externa, considera usar este patrón para convertirlos en
  styled-components. El mismo patrón funciona con tus propios componentes también, sí necesitas
  que algún componente se mantenga sin estilo por sí mismo.

  ```react
  // Esto puede ser el Link de react-router por ejemplo
  const Link = ({ className, children }) => (
    <a className={className}>
      {children}
    </a>
  )

  const StyledLink = styled(Link)`
    color: palevioletred;
    font-weight: bold;
  `;

  render(
    <div>
      <Link>Link sin estilo, aburrido</Link>
      <br />
      <StyledLink>Link emocionante, estilizado</StyledLink>
    </div>
  );
  ```

  Considera cuidadosamente envolver tus componentes en un "styled-component", cuando no es necesario,
  deshabilitarás el "whitelisting" automático de "props", y revertirás el orden recomendado de
  styled-components y componentes estructurales.

  También puedes pasar nombres de etiquetas a la fábrica `styled()` en su llamada, por ejemplo: `styled('div')`.
  De hecho, los ayudantes `styled.etiqueta` son sólo alias que hacen lo mismo.

  > styled-components siempre genera una hoja de estilos real con clases.
  > Los nombres de clase son pasados al componente de React (incluyendo componentes de terceros)
  > A través del "prop" `className`
extendingStyles: |
  ## Extendiendo estilos | v2

  Frecuentemente te gustaría usar un componente, y cambiarlo ligeramente en un sólo caso.
  Puedes pasar una función  interpolada y cambiarlo basado en algunos "props", pero eso
  es mucho esfuerzo para sobreescribir los estilos una sola vez.

  Para hacer esto más facilmente, puedes llamar `extend` en el componente para generar otro nuevo.
  Lo estilizas como cualquier otro componente y éste sobreescribe los estilos duplicados del
  componente original y mantiene los nuevos.

  Aquí uamos un botón de la última sección y creamos uno especial, extendiéndolo con unos estilos
  relativos a su color.

  ```react
  // El botón de la última sección sin interpolaciones
  const Button = styled.button`
    color: palevioletred;
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  // Estamos extendiendo el botón con unos estilos extra
  const TomatoButton = Button.extend`
    color: tomato;
    border-color: tomato;
  `;

  render(
    <div>
      <Button>Botón normal</Button>
      <TomatoButton>Botón tomate</TomatoButton>
    </div>
  );
  ```

  Podemos ver que el nuevo `TomatoButton` aún se asemeja a `Button`, cuándo sólo le añadimos dos
  reglas nuevas.

  > Sólo debes usar `Comp.estend` sí sabes que ese `Comp` es un "styled-component".
  > Si estás importando de otro archivo o librería de terceros, es mejor que uses
  > `styled(Comp)` ya que logra el mismo resultado, pero functiona con *cualquier* componente de
  > React. Lee más acerca de [las diferencias entre `Comp.extend` y `styled(Comp)`](/es/docs/#)

  En los muy raros casos que quieras cambiar que etiqueta o componente renderiza el "styled-component".
  Tenemos una manera de solucionarlo. Puedes usar el <Code>withComponent</Code> para extender los
  estilos y usar una etiqueta completamente diferente.

  ```react
  const Button = styled.button`
    display: inline-block;
    color: palevioletred;
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;
  `;

  // Estamos reemplazando la etiqueta <button> con una etiqueta <a>, pero reusamos todos los estilos
  const Link = Button.withComponent('a')

  // Usa `.withComponent` junto a `.extend` para cambiar la etiqueta y usar estilos adicionales
  const TomatoLink = Link.extend`
    color: tomato;
    border-color: tomato;
  `;

  render(
    <div>
      <Button>Normal Button</Button>
      <Link>Normal Link</Link>
      <TomatoLink>Tomato Link</TomatoLink>
    </div>
  );
  ```
attachingAdditionalProps: |
  ## Adjuntando "props" adicionales | v2

  Para evitar envolturas innecesarias que sólo pasan algunos "props" al componente renderizado,
  o elemento, puedes usar el constructor `.attrs`. Éste te permite adjuntar "props" adicionales
  (o atributos) a un componente. Además, puedes añadir más "props" dinámicos a un componente. El
  objeto `.attrs` también recive funciones, que reciben "props" que el componente recibe. El valor
  de resultado se combinará a los "props" resultantes también.

  Aquí renderizamos un componente `Input` y le adjuntamos algunos atributos estáticos y dinámicos:

  ```react
  const Input = styled.input.attrs({
    // Podemos definir "props" estáticos
    type: 'password',

    // o podemos definirlos dinámicos
    margin: props => props.size || '1em',
    padding: props => props.size || '1em'
  })`
    color: palevioletred;
    font-size: 1em;
    border: 2px solid palevioletred;
    border-radius: 3px;

    /* aquí usamos "props" calculados dinamicamente */
    margin: ${props => props.margin};
    padding: ${props => props.padding};
  `;

  render(
    <div>
      <Input placeholder="un input de texto pequeño" size="1em" />
      <br />
      <Input placeholder="un input de texto más grande" size="2em" />
    </div>
  );
  ```

  Como puedes ver, tenemos acceso a nuestros nuevos "props" creados en las interpolaciones, y el
  atributo `type` es pasado hacia abajo al elemento.
animations: |
  ## Animaciones

  Las animaciones de CSS con `@keyframes` no tienen alcance sólo para un componente, pero aún así,
  no quieres tenerlos de manera global. Es por eso que exportamos un ayudante `keyframes` el cual
  genera un nombre único para tus "keyframes". Puedes usar el nombre único en toda tu app.

  De esta manera, tienes todos los beneficios de usar JavaScript, evitando conflicto de nombres y
  tener tus "keyframes" como siempre:

  ```react
  // keyframes retorna un nombre único basado en los contenidos de los "keyframes"
  const rotate360 = keyframes`
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  `;

  // Aquí creamos un componente que girará todo lo que pasemos en dos segundos
  const Rotate = styled.div`
    display: inline-block;
    animation: ${rotate360} 2s linear infinite;
    padding: 2rem 1rem;
    font-size: 1.2rem;
  `;

  render(
    <Rotate>&lt; 💅 &gt;</Rotate>
  );
  ```
reactNative: |
  ## React Native

  styled-components puede usarse con "React Native" en la misma manera,
  excepto que necesitas importarlo de `styled-components/native`.

  ```jsx
  import React from 'react'
  import styled from 'styled-components/native';

  const StyledView = styled.View`
    background-color: papayawhip;
  `;

  const StyledText = styled.Text`
    color: palevioletred;
  `;

  class MyReactNativeComponent extends React.Component {
    render() {
      return (
        <StyledView>
          <StyledText>¡Hola Mundo!</StyledText>
        </StyledView>
      )
    }
  }
  ```

  También soportamos estilos más complejos (como `transform`), los cuales, normalmente serían un arreglo,
  (por ejemplo para `margin`) ¡Gracias a `css-to-react-native`!

  Imagina como escribirías una propiedad en React Native, adivina como lo transferirías a CSS,
  y posiblemente estés en lo correcto:

  ```jsx
  const RotatedBox = styled.View`
    transform: rotate(90deg);
    text-shadow-offset: 10px 5px;
    font-variant: small-caps;
    margin: 5px 7px 2px;
  `;
  ```

  Algunas de las diferencias con la versión web, son que no puedes usar los ayudantes `keyframes` e
  `injectGlobal` ya que React Native no soporta "keyframes" o estilos globales.También te advertimos
  si usas "media queries" o CSS anidado.

  > En la v2 soportamos porcentajes. Para hacerlo posible necesitamos forzar las unidades en todas
  > las abreviaciones. Si estás migrando a la v2,
  > [Hay un ejemplo en codemod](https://github.com/styled-components/styled-components-native-code-mod).
advancedDescription: |
  Uso avanzado de styled-components - Tematización, refs, seguridad, CSS existente, Media Templates,
  Tagged Template Literals, SSR
theming: |
  ## Tematización

  styled-components tiene soporte completo para tematización exportando un componente `<ThemeProvider>`.
  Éste componente provee un tema a todos los componentes de React debajo de él via el API de contexto.
  en el árbol de renderizado todos los "styled-components" tendrán acceso al tema provisto, incluso
  cuando están a varios niveles de profundidad.

  Para ilustrar mejor esto, vamos a crear nuestro componente Botón, pero ésta vez pasaremos algunas
  variables como un tema.

  ```react
  // Definimos nuestro botó, pero usando props.theme ésta vez
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Colorea el borde y texto con theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Estamos pasando el tema por default para botones que no están envueltos por un "ThemeProvider"
  Button.defaultProps = {
    theme: {
      main: 'palevioletred'
    }
  }

  // Definimos cómo lucirá props.theme
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button>Normal</Button>

      <ThemeProvider theme={theme}>
        <Button>Tematizado</Button>
      </ThemeProvider>
    </div>
  );
  ```

  ### Funciones de temas

  También puedes pasar una función para "prop" de tema. Ésta funcióm recivirá el tema padre, enviado
  por otro `<ThemeProvider>` más arriba en el árbol. De ésta manera, los temas pueden hacerse contextuales.

  Este ejemplo renderiza nuestro tema botón tematizado y un segundo que isa un segundo ThemeProvider
  que invierte el color de fondo. La función `invertTheme` (Invertir tema) recive el tema superior y
  crea uno nuevo.

  ```react
  // Definimos nuestro botón, pro con el uso de props.theme ésta vez
  const Button = styled.button`
    color: ${props => props.theme.fg};
    border: 2px solid ${props => props.theme.fg};
    background: ${props => props.theme.bg};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;
  `;

  // Definimos nuestro `fg` y `bg` en el tema
  const theme = {
    fg: 'palevioletred',
    bg: 'white'
  };

  // Éste tema invierte `fg` y `bg`
  const invertTheme = ({ fg, bg }) => ({
    fg: bg,
    bg: fg
  });

  render(
    <ThemeProvider theme={theme}>
      <div>
        <Button>Tema por default</Button>

        <ThemeProvider theme={invertTheme}>
          <Button>Tema invertido</Button>
        </ThemeProvider>
      </div>
    </ThemeProvider>
  );
  ```

  ### Comenzando con el tema sin "styled-components"

  Sí alguna vez necesitas usar el tema actual fuera de "styled-components" (por ejemplo, dentro de
  componentes muy grandes), puedes usar el componente de alto órden `withTheme`.

  ```jsx
  import { withTheme } from 'styled-components'

  class MyComponent extends React.Component {
    render() {
      console.log('Tema actual: ', this.props.theme);
      // ...
    }
  }

  export default withTheme(MyComponent)
  ```

  ### la propiedad `theme`

  Un tema puede ser pasado hacía abajo a un componente usando el "prop" `theme`.

  Esto es útil para burlar a un `ThemeProvider` ausente o sobreescribirlo.

  ```react
  // Definimos nuestro botón
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Colorea el borde y texto con theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Definimos como el tema principal lucirá
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button theme={{ main: 'royalblue' }}>Tema ad hoc</Button>
      <ThemeProvider theme={theme}>
        <div>
          <Button>Tematizado</Button>
          <Button theme={{ main: 'darkorange' }}>Sobreescrito</Button>
        </div>
      </ThemeProvider>
    </div>
  );
  ```
refs: |
  ## Refs

  Pasando un "prop" `ref` a un "styled-component" te dará una instancia de una envoltura `StyledComponent`,
  pero no el elemento DOM subyacente.
  Esto es debido a como "refs" funciona.
  No es posible utilizar métodos de DOM como `focus` en nuestros componentes directamente.

  Para obtener un "ref" con el nodo DOM envuelto, pasa una función "callback" al "prop" `innerRef`.

  > No soportamos refs como cadena (por ejemplo, `innerRef="node"`), ya que están obsoletos en React.

  Este ejemplo utiliza `innerRef` para guardar la referencia al input estilizado y lo enfoca una vez
  que el usuario pasa el ratón sobre él.

  ```react
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  class Form extends React.Component {
    render() {
      return (
        <Input
          placeholder="Pasa el ratón por aquí..."
          innerRef={x => { this.input = x }}
          onMouseEnter={() => this.input.focus()}
        />
      );
    }
  }

  render(
    <Form />
  );
  ```
security: |
  ## Seguridad

  Ya que "styled-components" te permite usar entradas arbitriarias como interpolaciones, debes de
  ser cuidadoso de como limpiar esa entrada. Usando entradas de usuario como estilos, puede llevar
  a que cualquier CSS se evalúe en el navegador del usuario que un agresor puede poner en tu aplicación.

  Este ejemplo muestra como una mala entrada de usuario puede llevar a llamadas a APIs en nombre del
  usuario.

  ```jsx
  // ¡Oh no, el usuario ha dado una mala URL!
  const userInput = '/api/retirar-fondos';

  const ArbitraryComponent = styled.div`
    background: url(${userInput});
    /* Más estilos aquí... */
  `;
  ```

  ¡Ten mucho cuidado! Ésto es obvuamente un ejemplo inventado, pero la inyección de CSS puede no ser
  nada obvia y puede tener malas repercuciones. Algunas versiones de IE incluso pueden ejecutar
  JavaScript arbitriario dentro de la declaración de url.

  Hay un estándar de como limpiar CSS dentro de JavaScript,
  [`CSS.escape`](https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).
  No está muy bien soportado a través de los exploradores aún, así que recomendamos también utilizar el
  [polyfill por Mathias Bynens](https://github.com/mathiasbynens/CSS.escape) en tu app.
existingCSS: |
  ## CSS existente

  Hay ciertos detalles de implementación de los cuales necesitas estar consciente, si eliges usar
  styled-components junto a CSS existente.

  styled-components genera una hoja de estilos con clases y adjunta esas clases a los nodos de
  DOM del "styled-component" a través del "prop" `className`.
  Inyecta la hoja de estilos generada al final del `head` del documento durante ejecución.

  ### Estilizando componentes de React normales

  Sí usas la notación `styled(MiComponente)` y `MiComponente` no renderiza el `className` enviado,
  entonces ningún estilo se ha aplicado. Para evitar este problema, asegurate que tu componente
  adjunte el `className` enviado al nodo de DOM:

  ```jsx
  class MiComponente extends React.Component {
    render() {
      // Adjunta el `className` enviado al nodo de DOM
      return <div className={this.props.className} />;
    }
  }
  ```

  Si tienes algunos estilos preexistentes con una clase, puedes combinar la clase global con la
  enviada:

  ```jsx
  class MiComponente extends React.Component {
    render() {
      // Adjunta el `className` enviado al nodo de DOM
      return <div className={`alguna-clase-global ${this.props.className}`} />;
    }
  }
  ```

  ### Problemas con la especificidad

  Si aplicas una clase global junto a una clase de "styled-component", el resultado puede que no
  sea lo que estás esperando. Si una propiedad está definida en ambas clases con la misma
  especificidad, la última es la que se aplicará.

  ```jsx
  // MiComponente.js
  const MiComponente = styled.div`background-color: green;`;

  // mi-componente.css
  .bg-rojo {
    background-color: red;
  }

  // Por alguna razón este componente aún tendrá el fondo color verde,
  // ¡Incluso cuando estás tratando de sobreescribirlo con la clase "bg-rojo"!
  <MiComponente className="bg-rojo" />
  ```

  En el ejemplo de arriba, la clase del "styled-component" tiene precedencia sobre la clase global,
  ya que styled-components inyecta sus estilos durante ejecución dentro del DOM al final del head.
  Por lo tanto, sus estilos ganan sobre otros.

  Ya que es difícil controlar donde tu CSS global es inyectado al DOM con herramientas como Webpack,
  la manera más sencilla de subir la especificidad de tu clase global repitiendo el nombre de clase:

  ```css
  /* mi-componente.css */
  .bg-rojo.bg-rojo {
    background-color: red;
  }
  ```
mediaTemplates: |
  ## Media Templates

  Los "Media queries" son una herramienta indispensable cuando se desarrollan aplicaciones web
  responsivas.

  Este es un ejemplo muy simple. Muestra a un componente básico cambiando su color de fondo, una
  vez que el ancho de la pantalla es menor al límite de `700px`.

  ```react
  const Content = styled.div`
    background: papayawhip;
    height: 3em;
    width: 3em;

    @media (max-width: 700px) {
      background: palevioletred;
    }
  `;

  render(
    <Content />
  );
  ```

  Ya que los "media queries" son largos y muchas veces repetidos a través de las aplicaciones, es
  útil crear un componente para ellos.

  Debido a la naturaleza funcional de JavaScript, puedes facilmente definir tu propio "template literal"
  para cambiar estilos dentro de "media queries". Reescribamos el último ejemplo para probar justo eso.

  ```react
  const sizes = {
    desktop: 992,
    tablet: 768,
    phone: 376
  }

  // Iterar a través de los tamaños y crear un "media template"
  const media = Object.keys(sizes).reduce((acc, label) => {
    acc[label] = (...args) => css`
      @media (max-width: ${sizes[label] / 16}em) {
        ${css(...args)}
      }
    `

    return acc
  }, {})

  const Content = styled.div`
    height: 3em;
    width: 3em;
    background: papayawhip;

    /* Ahora tenemos nuestros métodos de media y podemos usarlos en vez de utilizarlos directamente */
    ${media.desktop`background: dodgerblue;`}
    ${media.tablet`background: mediumseagreen;`}
    ${media.phone`background: palevioletred;`}
  `;

  render(
    <Content />
  );
  ```
taggedTemplateLiterals: |
  ## Tagged Template Literals

  Las "tagged template literals" son una característica nueva en ES6. Te permiten definir reglas
  customizadas de interpolación. Que es como somos capaces de crear "styled-components".

  Si no pasas interpolaciones, el primer argumento de tu función, recibe un arreglo con la cadena en él.

  ```jsx
  // Estos son equivalentes:
  fn`una cadena aquí`;
  fn([ 'una cadena aquí' ]);
  ```

  Una vez que pases las interpolaciones, el arreglo contiene la cadena enviada, separada en las
  posiciones de las interpolaciones. El resto de los argumentos serán las interpolaciones en órden.

  ```jsx
  const aVar = 'buen';

  // Éstos son equivalentes:
  fn`este es un ${aVar} día`;
  fn([ 'este es un ', ' día' ], aVar);
  ```

  Esto es un poco engorroso para trabajar, pero significa que podemos recibir variables, funciones, o
  mixins (ayudante de `css`) en los "styled components" y se puede convertir a CSS puro.

  Si quieres aprender más sobre "tagged template literals", revisa el artículo de Max Stoiber:
  [The magic behind 💅 styled-components](https://mxstbr.blog/2016/11/styled-components-magic-explained/)
serverSideRendering: |
  ## Renderizado del lado del servidor | v2

  styled-components soporta renderizado del lado del servidor de manera concurrente, con rehidratación
  de hojas de estilo. La idea básica es que cada vez que renderices tu app en el servidor, puedes
  crear un `ServerStyleSheet` y añadirlo a un "provider" en tu árbol de React, esto acepta estilos
  via el API de contexto.

  Esto no interfiere con los estilos globales. como por ejemplo `keyframes` o `injectGlobal` además
  te permite usar styled-components con el SSR de React DOM o incluso Rapscallion.

  El API básico va de la siguiente manera:

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(sheet.collectStyles(<TuApp />))
  const styleTags = sheet.getStyleTags() // o sheet.getStyleElement()
  ```

  El método `collectStyles` envuelve tu elemento en un proveedor. Opcionalmente puedes usar el
  proveedor `StyleSheetManager` directamente, en vez de éste método. Tan sólo asegurate de no usarlo
  en el lado del cliente.

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet, StyleSheetManager } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(
    <StyleSheetManager sheet={sheet.instance}>
      <TuApp />
    </StyleSheetManager>
  )

  const styleTags = sheet.getStyleTags() // o sheet.getStyleElement()
  ```

  `sheet.getStyleTags()` retorna una cadena de múltiples etiquetas `<style>`.
  Necesitas tomar esto en cuenta cuando añadas la cadena de CSS a tu salida de HTML.

  Alternativamente la instancia de `ServerStyleSheet` también tiene un método `getStyleElement()`
  que retorna un arreglo de elementos de React.

  ### Next.js

  En Next.js, necesitarás estructurar tu archivo `_document.js` de manera diferente, que la que se
  provee en su ejemplo de su repositorio para la versión 1.

  ```jsx
  import Document, { Head, Main, NextScript } from 'next/document'
  import { ServerStyleSheet } from 'styled-components'

  export default class MyDocument extends Document {
    static getInitialProps ({ renderPage }) {
      const sheet = new ServerStyleSheet()
      const page = renderPage(App => props => sheet.collectStyles(<App {...props} />))
      const styleTags = sheet.getStyleElement()
      return {
        ...page,
        styleTags
      }
    }

    render() {
      return (
        <html>
          <Head>
            {/* ... */}

            {this.props.styleTags}
          </Head>
          <body>
            <Main />
            <NextScript />
          </body>
        </html>
      )
    }
  }
  ```

  Necesitarás usar `babel-plugin-styled-components` para que esto funcione.
  Más detalles [aquí](https://www.npmjs.com/package/babel-plugin-styled-components)

  Refiérete a [nuestro ejemplo](https://github.com/zeit/next.js/tree/master/examples/with-styled-components)
  en el repositorio de Next.js de un ejemplo de uso actualizado.
