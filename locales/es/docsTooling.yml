babelPlugin: |
  ## Plugin de Babel| v2

  Este plugin a침ade soporte para renderizado del lado del servidor, para minificaci칩n de estilos
  y da una mejor experiencia de debugeo.

  ### Uso

  Primero instala el plugin de babel:

  ```
  npm install --save-dev babel-plugin-styled-components
  ```

  Despu칠s a침adelo a tu configuraci칩n de babel de la siguiente manera:

  > 丘멆잺 El orden de llamada del plugin en tu ```.babelrc``` importa. Si usas la propiedad env
  > en tu configuraci칩n de babel. entonces poner 칠ste plugin en el arreglo de plugins no ser치 suficiente.
  > En cambio, necesita ser puesto en cada arreglo de plugins de cada "env" para que mantenga ser
  > ejecutado primero.
  > Ve [esto](https://github.com/styled-components/babel-plugin-styled-components/issues/78)
  > para m치s informaci칩n.

  ```js
  {
    "plugins": ["babel-plugin-styled-components"]
  }
  ```

  ### Renderizado del lado del servidor

  > Esta opci칩n est치 desactivada por default

  A침adiendo un identificador 칰nico por cada "styled component" este plugin evita desajustes en
  el checksum debido a la generaci쯡 de clases diferente en el servidor y en el cliente. Si no usas
  este plugin y tratas de hacer renderizado del lado del servidor de styled-components, React se
  quejar치.

  Puedes activar esto en la opci칩n de `ssr`:

  ```js
  {
    "plugins": [
      ["babel-plugin-styled-components", {
        "ssr": true
      }]
    ]
  }
  ```

  ### Mejor debugeo

  Esta opci칩n a침ade el nombre y displayName del componente al nombre de clase adjuntado al nodo
  de DOM. En el DevTools de tu browser ver치s:
  `<button class="Button-asdf123 asdf123" />`
  en lugar de s칩lo `<button class="asdf123" />`.

  Adem치s esto a침ade soporte para mostrar el nombre real de tu componente en el DevTools de React.
  Considera escribir un "styled component" que renderize un elemento `button` llamado `MiBoton`.
  Normalmente lo mostrar치 como `<styled.button>` para todos tus componentes, pero con este plugin,
  se mostrar치n como `<MiBoton />`.

  Esto hace m치s f치cil encontrar tus componentes y descifrar donde viven en tu aplicaci칩n.

  Si no necesitas esta caracter칤stica, puedes desactivarla en la opci칩n de `displayName`:

  ```
  {
    "plugins": [
      ["babel-plugin-styled-components", {
        "displayName": false
      }]
    ]
  }
  ```

  ### Preprocesamiento

  > 춰Esto es experimental y no sabemos las limitaciones y errores!
  > No est치 listo para producci칩n por ahora. 丘멆잺

  Este plugin preprocesa tus estilos con stylis y usa el punto de entrada `no-parser.js`
  en styled-components. Esto elimina efectivamente stylis de tu ejecici칩n de paquete y debe de mejorar
  un poco el rendimiento de ejecuci칩n y reducir el tama침o del paquete.

  Autom치ticamente deshabilita la opci칩n de `minify`, ya que stylis ya hace algo de minificaci칩n
  en tu CSS.

  Puedes activar el preprocesamiento con la opci칩n de `preprocess`:

  ```js
  {
    "plugins": [
      ["babel-plugin-styled-components", {
        "preprocess": true
      }]
    ]
  }
  ```

  ### Minificaci칩n

  > Esta opci칩n est치 activada por defecto. Si experimentas resultados estropeados de CSS,
  > desactiva la opci칩n y reporta el problema por favor.

  Este plugin minifica tus estilos en los "tagged templ literals", d치ndole a tu paquete, grandes
  ahorros de tama침o.

  Esta operaci칩n posiblemente rompa tus estilos en algunos raros casos, as칤 que te recomendamos
  dejar esta opci칩n activada durante el desarrollo si est치 activada en producci칩n.

  Puedes desactivar la minificaci칩n en la opci칩n de `minify`:

  ```js
  {
    "plugins": [
      ["babel-plugin-styled-components", {
        "minify": false
      }]
    ]
  }
  ```

  ### Transpilaci칩n de Template String

  Transpilamos "tagged template literals" de `styled-components` a una representaci칩n m치s peque침a
  que Babel normalmente usa, porque los "template literals" de `styled-components` no necesitan
  ser 100% compatibles con las especificaciones.

  Lee m치s acerca de [Tagged Template Literals](#tagged-template-literals) en nuestra secci칩n
  dedicada a ellos.

  Puedes usar la opci칩n de `transpileTemplateLiterals` para desactivar esta caracter칤stica.

  ```js
  {
    "plugins": [
      ["babel-plugin-styled-components", {
        "transpileTemplateLiterals": false
      }]
    ]
  }
  ```
testUtilities: |
  ## Utilidades para pruebas

  [Jest Styled Components](https://github.com/styled-components/jest-styled-components) es un set
  de utilidades para probar "Styled Components" con [Jest](https://github.com/facebook/jest).
  Este paquete mejora la experiencia de probar con snapshot y provee un comparador nuevo para
  hacer excepciones con las reglas de estilo.

  ### Instalaci칩n

  ```
  yarn add --dev jest-styled-components
  ```

  ### Pruebas con snapshot

  Cuando construimos una Interfaz de usuario con "Styled Components", queremos asegurarnos que el
  resultado no cambie inesperadamente. Pruebas con snapshot son una excelente forma de probar
  componentes de React, y este paquete hace que la experiencia sea a칰n m치s placentera, a침adiendo
  el estilo a los snapshot.

  Aqu칤 hay un ejemplo de una prueba:

  ```jsx
  import React from 'react'
  import styled from 'styled-components'
  import renderer from 'react-test-renderer'
  import 'jest-styled-components'

  const Button = styled.button`
    color: red;
  `

  test('funciona', () => {
    const tree = renderer.create(<Button />).toJSON()
    expect(tree).toMatchSnapshot()
  })
  ```

  Y aqu칤 hay un ejemplo del snapshot resultante:

  ```jsx
  exports[`funciona 1`] = `
  .c0 {
    color: green;
  }

  <button
    className="c0"
  />
  `;
  ```

  Para un ejemplo del mundo real, revisa
  [el sitio web de este repositorio](https://github.com/styled-components/styled-components-website/tree/master/test).

  ### `toHaveStyleRule`

  Si s칩lo queremos revisar que un estilo en particular se ha aplicado a un elemento, podemos usar
  el comparador `toHaveStyleRule`. Esta funci칩n toma dos par치metros, una propiedad (cadena) y
  un valor (cadena o expresi칩n regular), y opcionalmente un objeto para buscar por reglas anidadas
  dentro de la regla, o para modificar la clase de selector.

  ```jsx
  import React from 'react'
  import styled from 'styled-components'
  import renderer from 'react-test-renderer'
  import 'jest-styled-components'

  const Button = styled.button`
    color: red;
    @media (max-width: 640px) {
      &:hover {
        color: green;
      }
    }
  `

  test('funciona', () => {
    const tree = renderer.create(<Button />).toJSON()
    expect(tree).toHaveStyleRule('color', 'red')
    expect(tree).toHaveStyleRule('color', 'green', {
      media: '(max-width: 640px)',
      modifier: ':hover',
    })
  })
  ```
stylelint: |
  ## Stylelint

    춰Aplica lint a tus [styled components](https://github.com/styled-components/styled-components)
    con [stylelint](http://stylelint.io/)!

  ### Instalaci칩n

  Necesitas:

  - `stylelint` (duh)
  - Este procesador, para extraer estilos de `styled-components`
  - [`stylelint-config-styled-components`](https://github.com/styled-components/stylelint-config-styled-components) para deshabilitar las reglas de stylelint que chocan con `styled-components`
  - 춰Tu configuraci칩n favorita de `eslint`! (por ejemplo [`stylelint-config-standard`](https://github.com/stylelint/stylelint-config-standard))

  ```
  (npm install --save-dev
    stylelint
    stylelint-processor-styled-components
    stylelint-config-styled-components
    stylelint-config-standard)
  ```

  ### Preparaci칩n

  crea un archivo `.stylelintrc` en la ra칤z de tu proyecto:

  ```JSON
  {
    "processors": ["stylelint-processor-styled-components"],
    "extends": [
      "stylelint-config-standard",
      "stylelint-config-styled-components"
    ],
    "syntax": "scss"
  }
  ```

  > 춰Configurando `syntax` como `scss` Es necesario para soporte de anidaciones e interpolaciones!

  Despu칠s debes de ejecutar `stylelint`. A침ade un script `lint:css` a tu `package.json` que
  ejecute `stylelint` con alcance a todos tus "styled components":

  ```JSON
  {
    "scripts": {
      "lint:css": "stylelint './src/**/*.js'"
    }
  }
  ```

  > El procesador ignora archivos de javascript que no contengan ning칰n `styled-components`, as칤
  > que no te preocupes demasiado amplio, mientras lo restrinjas a javascript (o TypeScript).

  춰Ahora puedes aplicar lint a tu CSS ejecutando el script! 游꿀

  ```
  npm run lint:css
  ```

  > Ten cuidado, debido a las limitantes en lo que es posible para procesadores de Stylelint
  > personalizados, no podemos dar soporte a la opci칩n `--fix`

  #### Webpack

  Si quieres aplicar lint al compilar, en lugar de tenerlo como comando separado, puedes usar el
  [`stylelint-custom-processor-loader`](https://github.com/emilgoldsmith/stylelint-custom-processor-loader)
  para webpack.

  ### `stylelint-config-styled-components`

  Cuando se usa este procesador, un par de reglas de stylelint arrojan errores que no pueden ser
  evitados, como  [`no-empty-source`](https://stylelint.io/user-guide/rules/no-empty-source) o
  [`no-missing-end-of-source-newline`](https://stylelint.io/user-guide/rules/no-missing-end-of-source-newline).
  Tambi칠n hay un par de reglas que necesitamos forzar, como
  [`no-vendor-prefix` rules](https://stylelint.io/user-guide/rules/property-no-vendor-prefix).
  (`styled-components` automaticamente a침ade prefijos de navegador a tu c칩digo, para que no
  tengas que hacerlo manualmente)


  [`stylelint-config-styled-components`](https://github.com/styled-components/stylelint-config-styled-components)
  automaticamente deshabilitar치 las reglas que causen conflictos.

  > Puedes sobreescribir las reglas definidas en configuraciones compartidas en tu `.stylelintrc`
  > personalizado.

  ### Uso junto a otras librer칤as

  Algunas otras librer칤as tambi칠n implementan el patr칩n `styled.x` con "tagged template literals".
  Este procesador tambi칠n aplicar치 lint al CSS en esos "tagged template literals", siempre que usen
  la palabra clave `styled`.

  Si quieres usar un procesador de otra librer칤a, pero tambi칠n quieres cambiar la palabra clave
  (por ejemplo, para escribir `cool.div` en lugar de `styled.div`) usa la opci칩n de `moduleName`:

  ```js
  import cool from 'otra-libreria';

  const Button = cool.button`
    color: blue;
  `
  ```

  ```json
  {
    "processors": [["stylelint-processor-styled-components", {
        "moduleName": "otra-libreria"
    }]]
  }
  ```

  > El doble arreglo es a prop칩sito, pero s칩lo necesario si tu configuras opciones, revisa la
  > [la documentaci칩n de la configuraci칩n de procesadores](https://stylelint.io/user-guide/configuration/#processors).

  > Oficialmente, s칩lo soportamos `styled-components`, pero esperamos que otras librer칤as se
  > beneficien de este procesador.

  ### Interpolaciones de etiquetas

  Algunas veces, `stylelint` puede arrojar un error (por ejemplo, `CssSyntaxError`) aunque nada est칠
  mal en tu CSS. A menudo es por una interpolaci칩n, m치s espec칤ficamente el hecho que el procesador
  no sabe que est치s interpolando.

  Un ejemplo simplificado:

  ```js
  const algo = 'background';

  const Button = styled.div`
    ${algo}: papayawhip;
  `
  ```

  Cuando tienes interpolaciones en tus estilos, el procesador no puede saber que son, as칤 que
  hace una buena siposici칩n y los reemplaza con un valor equivalente sint칠tico. Ya que `stylelint`
  no es una herramienta de an치lisis de flujo de c칩digo, no cubre todos los casos y el procesador
  se equivocar치 de vez en cuando.

  La interpolaci칩n de etiquetas te permite decirle al procesador que es una interpolaci칩n en caso
  de que haga una mala suposici칩n. Puede reemplazar la interpolaci칩n con un valor sint칠tico correcto
  basado en tu etiqueta.

  Por ejemplo:

  ```js
  const algo = 'background';

  const Button = styled.div`
    // Le dice al procesador que "algo" es una propiedad
    ${/* sc-prop */ algo}: papayawhip;
  `
  ```

  Ahora el procesador sabe que la interpolaci칩n `algo` es una propiedad, y puede reemplazar la
  interpolaci칩n con una propiedad para el lint.

  Para etiquetar una interpolaci칩n, a침ade un comentario al inicio o al final de la interpolaci칩n.
  (`${/* sc-tag */ foo}` o `${bar /* sc-tag */}`) Etiquetas empezando con `sc-` y, s칤 es espec칤ficado,
  una etiqueta sobreescribe la suposici칩n del procesador acerca de que es la interpolaci칩n.

  #### Etiquetas

  Lista de etiquetas soportadas:

  - `sc-block`
  - `sc-selector`
  - `sc-declaration`
  - `sc-property`
  - `sc-value`

  > Si est치s en duda con el vocabulario, puedes referirte a
  > [Esta lista de vocabulario de CSS](http://apps.workflower.fi/vocabs/css/en) con ejemplos.

  Por ejemplo, cuando interpolas otro "styled component", lo que realmente interpolas es un
  selector 칰nico. Ya que el procesador no sabe eso, puedes decirle que lo reemplace con un selector
  cuando se aplique lint:

  ```js
  const Wrapper = styled.div`
    ${/* sc-selector */ Button} {
      color: red;
    }
  `;
  ```

  Tambi칠n puedes usar abreviaciones de etiquetas para evitar agregar demasiado ruido al c칩digo,
  por ejemplo:

  ```js
  const Wrapper = styled.div`
    ${/* sc-sel */ Button} {
      color: red;
    }
  `;
  ```

  ##### `sc-custom`

  **춰`sc-custom` debe de usarse como 칰ltimo recurso. Usa las etiquetas est치ndar si es posible!**

  En cima de las etiquetas est치ndar, el procesador tiene tambi칠n la etiqueta `sc-custom` la cual
  te permite cubrir casos 칰nicos y casos poco habituales. Con la etiqueta de `sc-custom` puedes
  decidir que valor tendr치.

  Por ejemplo:

  ```js
  // Cambia entre izquierda y derecha basado en lenguaje pasado a trav칠s del tema
  const rtlSwitch = props => props.theme.dir === 'rtl' ? 'left' : 'right';

  const Button = styled.button`
    background: green;
    // Le dice al procesador que reemplace la interpolaci칩n con "left"
    // cuando se aplique lint
    margin-${/* sc-custom 'left' */ rtlSwitch}: 12.5px;
  `;
  ```

  ### Notas de sint치xis

  #### Desactivando reglas dentro de tu JS/CSS

  Desactiva reglas con comentarios `stylelint-disable` (ve la
  [documentaci칩n de stylelint](https://stylelint.io/user-guide/configuration/#turning-rules-off-from-within-your-css)
  para toda la sint치xis permitida) dentro y fuera de los "tagged template literals".

  ```js
  import React from 'react';
  import styled from 'styled-components';

  // Deshabilita stylelint dentro del "tagged template literal"
  const Wrapper = styled.div`
    /* stylelint-disable */
    background-color: 123;
  `;

  // O desde JavaScript fuera del "tagged template literal"
  /* stylelint-disable */
  const Wrapper = styled.div`
    background-color: 123;
  `;
  ```

  #### Estilo e indentaci칩n en "Template literals"

  Para que stylelint aplique correctamente las reglas de indentaci칩n, el procesador necesita hacer
  un poco de preprocesamiento en los estilos. Lo cual resulta en que s칩lo soportamos oficialmente un
  tipo de estilo de indentaci칩n (El estilo soportado es el predefinido como se muestra en toda
  la documentaci칩n)

  Lo importante es que pongas la comilla final (backtick del ingl칠s) en el nivel base de la
  indentaci칩n:

  **Correcto**

  ```js
  if (condition) {
    const Button = styled.button`
      color: red;
    `
  }
  ```

  **Incorrecto**

  ```js
  if (condition) {
    const Button = styled.button`
      color: red;
  `
  }
  ```

  ```js
  if (condition) {
    const Button = styled.button`
      color: red;`
  }
  ```

  Puede que otros estilos de etiquetas de "template literals" sean soportados por coincidencia,
  pero ning칰n error ser치 manejado a menos que se use el estilo que se ense침a arriba.
styledTheming:
  components:
    toggleMode: Activar/desactivar modo
    toggleSize: Activar/desactivar tama침o
  content: !!seq
    - |
      ## Tematizaci칩n estilizada

      Crea temas para tus "styled components" usando
      [styled-theming](https://github.com/styled-components/styled-theming)
    - |
      Lee el [la entrada del blog de introducci칩n](http://thejameskyle.com/styled-theming.html)

      ### Instalaci칩n

      Instala el plugin de babel primero:

      ```
      npm install --save styled-theming
      ```

      ### Ejemplo

      ```jsx
      import React from 'react';
      import styled, {ThemeProvider} from 'styled-components';
      import theme from 'styled-theming';

      const boxBackgroundColor = theme('mode', {
        light: '#fff',
        dark: '#000',
      });

      const Box = styled.div`
        background-color: ${boxBackgroundColor};
      `;

      export default function App() {
        return (
          <ThemeProvider theme={{ mode: 'light' }}>
            <Box>
              Hola Mundo
            </Box>
          </ThemeProvider>
        );
      }
      ```

      ### API

      #### `<ThemeProvider>`

      Revisa los [documentos destyled-components](https://www.styled-components.com/docs/advanced#theming)

      `<ThemeProvider>` es parte de styled-components, pero es requerido para styled-thming.

      ```js
      import {ThemeProvider} from 'styled-components';
      ```

      `<ThemeProvider>` Acepta un s칩lo "prop" `theme`, el cual debes de pasar como un objeto
      con cadenas o funciones "get", por ejemplo:

      ```jsx
      <ThemeProvider theme={{ mode: 'dark', size: 'large' }}>
      <ThemeProvider theme={{ mode: modes => modes.dark, size: sizes => sizes.large }}>
      ```

      Generalmente debes agregar un `<ThemeProvider>` en la ra칤z de tu aplicaci칩n:

      ```jsx
      function App() {
        return (
          <ThemeProvider theme={...}>
            {/* El resto de tu aplicaci칩n */}
          </ThemeProvider>
        );
      }
      ```

      #### `theme(nombre, valores)`

      Casi toda tu tematizaci칩n suceder치 en esta funci칩n.

      `nombre` Debe de ser igual a una d etus llaves en tu tema `<ThemeProvider>`.

      ```jsx
      <ThemeProvider theme={{ loQueSea: '...' }}/>
      ```

      ```js
      theme('loQueSea', {...});
      ```

      `valores` deben de ser un objeto donde una de las llaves ser치 elegida por el valor provisto
      al tema `<ThemeProvider>`.

      ```jsx
      <ThemeProvider theme={{ mode: 'claro' }}/>
      <ThemeProvider theme={{ mode: 'obscuro' }}/>

      theme('mode', {
        claro: '...',
        obscuro: '...',
      });
      ```

      Los valores de este objeto pueden ser cualquier valor de CSS.

      ```jsx
      theme('mode', {
        claro: '#fff',
        obscuro: '#000',
      });

      theme('font', {
        sansSerif: '"Helvetica Neue", Helvetica, Arial, sans-serif',
        serif: 'Georgia, Times, "Times New Roman", serif',
        monoSpaced: 'Consolas, monaco, monospace',
      });
      ```

      Los valores tambi칠n pueden ser funciones que retornen valores de CSS.

      ```jsx
      theme('mode', {
        claro: props => props.theme.colorDePerfilDeUsuario.claro,
        obscuro: props => props.theme.colorDePerfilDeUsuario.obscuro,
      });
      ```

      `theme` crear치 una funci칩n que puedes usar como un valor en la funci칩n `styled` de
      `styled-component`.

      ```jsx
      import styled from 'styled-components';
      import theme from 'styled-theming';

      const backgroundColor = theme('mode', {
        claro: '#fff',
        obscuro: '#000',
      });

      const Box = styled.div`
        background-color: ${backgroundColor}
      `;
      ```


      #### `theme.variants(nombre, prop, temas)`

      Es muy 칰til crear variantes del mismo componente que son elegidos a trav칠s de un "prop"
      adicional.

      Para hacer la tematizaci칩n m치s f치cil, styled-theming provee una funci칩n `theme.variants`.

      ```jsx
      import styled from 'styled-components';
      import theme from 'styled-theming';

      const backgroundColor = theme.variants('variant', 'mode', {
        default: { light: 'gray', dark: 'darkgray' },
        primary: { light: 'blue', dark: 'darkblue' },
        success: { light: 'green', dark: 'darkgreen' },
        warning: { light: 'orange', dark: 'darkorange' },
      });

      const Button = styled.button`
        background-color: ${backgroundColor};
      `;

      Button.propTypes = {
        variant: PropTypes.oneOf(['default', 'primary', 'success', 'warning'])
      };

      Button.defaultProps = {
        variant: 'default',
      };

      <Button/>
      <Button variant="primary"/>
      <Button variant="success"/>
      <Button variant="warning"/>
      ```
