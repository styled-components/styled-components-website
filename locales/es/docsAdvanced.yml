theming: |
  ## Tematizaci√≥n

  styled-components tiene soporte completo para tematizaci√≥n exportando un componente `<ThemeProvider>`.
  √âste componente provee un tema a todos los componentes de React debajo de √©l via el API de contexto.
  en el √°rbol de renderizado todos los "styled-components" tendr√°n acceso al tema provisto, incluso
  cuando est√°n a varios niveles de profundidad.

  Para ilustrar mejor esto, vamos a crear nuestro componente Bot√≥n, pero √©sta vez pasaremos algunas
  variables como un tema.

  ```react
  // Definimos nuestro bot√≥, pero usando props.theme √©sta vez
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Colorea el borde y texto con theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Estamos pasando el tema por default para botones que no est√°n envueltos por un "ThemeProvider"
  Button.defaultProps = {
    theme: {
      main: 'palevioletred'
    }
  }

  // Definimos c√≥mo lucir√° props.theme
  const theme = {
    main: 'mediumseagreen'
  };

  render(
    <div>
      <Button>Normal</Button>

      <ThemeProvider theme={theme}>
        <Button>Tematizado</Button>
      </ThemeProvider>
    </div>
  );
  ```

  ### Funciones de temas

  Tambi√©n puedes pasar una funci√≥n para "prop" de tema. √âsta funci√≥m recivir√° el tema padre, enviado
  por otro `<ThemeProvider>` m√°s arriba en el √°rbol. De √©sta manera, los temas pueden hacerse contextuales.

  Este ejemplo renderiza nuestro tema bot√≥n tematizado y un segundo que isa un segundo ThemeProvider
  que invierte el color de fondo. La funci√≥n `invertTheme` (Invertir tema) recive el tema superior y
  crea uno nuevo.

  ```react
  // Definimos nuestro bot√≥n, pro con el uso de props.theme √©sta vez
  const Button = styled.button`
    color: ${props => props.theme.fg};
    border: 2px solid ${props => props.theme.fg};
    background: ${props => props.theme.bg};

    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;
  `;

  // Definimos nuestro `fg` y `bg` en el tema
  const theme = {
    fg: 'palevioletred',
    bg: 'white'
  };

  // √âste tema invierte `fg` y `bg`
  const invertTheme = ({ fg, bg }) => ({
    fg: bg,
    bg: fg
  });

  render(
    <ThemeProvider theme={theme}>
      <div>
        <Button>Tema por default</Button>

        <ThemeProvider theme={invertTheme}>
          <Button>Tema invertido</Button>
        </ThemeProvider>
      </div>
    </ThemeProvider>
  );
  ```

  ### Comenzando con el tema sin "styled-components"

  S√≠ alguna vez necesitas usar el tema actual fuera de "styled-components" (por ejemplo, dentro de
  componentes muy grandes), puedes usar el componente de alto √≥rden `withTheme`.

  ```jsx
  import { withTheme } from 'styled-components'

  class MyComponent extends React.Component {
    render() {
      console.log('Tema actual: ', this.props.theme);
      // ...
    }
  }

  export default withTheme(MyComponent)
  ```

  ### la propiedad `theme`

  Un tema puede ser pasado hac√≠a abajo a un componente usando el "prop" `theme`.

  Esto es √∫til para burlar a un `ThemeProvider` ausente o sobreescribirlo.

  ```react
  // Definimos nuestro bot√≥n
  const Button = styled.button`
    font-size: 1em;
    margin: 1em;
    padding: 0.25em 1em;
    border-radius: 3px;

    /* Colorea el borde y texto con theme.main */
    color: ${props => props.theme.main};
    border: 2px solid ${props => props.theme.main};
  `;

  // Definimos como el tema principal lucir√°
  const theme = {
    main: 'mediumseagreen'
  };

  const adHocTheme = {
    main: 'royalblue'
  };

  const overiddenTheme = {
    main: 'darkorange'
  };

  render(
    <div>
      <Button theme={adHocTheme}>Tema ad hoc</Button>
      <ThemeProvider theme={theme}>
        <div>
          <Button>Tematizado</Button>
          <Button theme={overiddenTheme}>Sobreescrito</Button>
        </div>
      </ThemeProvider>
    </div>
  );
  ```
refs: |
  ## Refs

  Pasando un "prop" `ref` a un "styled-component" te dar√° una instancia de una envoltura `StyledComponent`,
  pero no el elemento DOM subyacente.
  Esto es debido a como "refs" funciona.
  No es posible utilizar m√©todos de DOM como `focus` en nuestros componentes directamente.

  Para obtener un "ref" con el nodo DOM envuelto, pasa una funci√≥n "callback" al "prop" `innerRef`.

  > No soportamos refs como cadena (por ejemplo, `innerRef="node"`), ya que est√°n obsoletos en React.

  Este ejemplo utiliza `innerRef` para guardar la referencia al input estilizado y lo enfoca una vez
  que el usuario pasa el rat√≥n sobre √©l.

  ```react
  const Input = styled.input`
    padding: 0.5em;
    margin: 0.5em;
    color: palevioletred;
    background: papayawhip;
    border: none;
    border-radius: 3px;
  `;

  class Form extends React.Component {
    render() {
      return (
        <Input
          placeholder="Pasa el rat√≥n por aqu√≠..."
          innerRef={x => { this.input = x }}
          onMouseEnter={() => this.input.focus()}
        />
      );
    }
  }

  render(
    <Form />
  );
  ```
security: |
  ## Seguridad

  Ya que "styled-components" te permite usar entradas arbitriarias como interpolaciones, debes de
  ser cuidadoso de como limpiar esa entrada. Usando entradas de usuario como estilos, puede llevar
  a que cualquier CSS se eval√∫e en el navegador del usuario que un agresor puede poner en tu aplicaci√≥n.

  Este ejemplo muestra como una mala entrada de usuario puede llevar a llamadas a APIs en nombre del
  usuario.

  ```jsx
  // ¬°Oh no, el usuario ha dado una mala URL!
  const userInput = '/api/retirar-fondos';

  const ArbitraryComponent = styled.div`
    background: url(${userInput});
    /* M√°s estilos aqu√≠... */
  `;
  ```

  ¬°Ten mucho cuidado! √âsto es obvuamente un ejemplo inventado, pero la inyecci√≥n de CSS puede no ser
  nada obvia y puede tener malas repercuciones. Algunas versiones de IE incluso pueden ejecutar
  JavaScript arbitriario dentro de la declaraci√≥n de url.

  Hay un est√°ndar de como limpiar CSS dentro de JavaScript,
  [`CSS.escape`](https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).
  No est√° muy bien soportado a trav√©s de los exploradores a√∫n, as√≠ que recomendamos tambi√©n utilizar el
  [polyfill por Mathias Bynens](https://github.com/mathiasbynens/CSS.escape) en tu aplicaci√≥n.
existingCSS: |
  ## CSS existente

  Hay ciertos detalles de implementaci√≥n de los cuales necesitas estar consciente, si eliges usar
  styled-components junto a CSS existente.

  styled-components genera una hoja de estilos con clases y adjunta esas clases a los nodos de
  DOM del "styled-component" a trav√©s del "prop" `className`.
  Inyecta la hoja de estilos generada al final del `head` del documento durante ejecuci√≥n.

  ### Estilizando componentes de React normales

  S√≠ usas la notaci√≥n `styled(MiComponente)` y `MiComponente` no renderiza el `className` enviado,
  entonces ning√∫n estilo se ha aplicado. Para evitar este problema, asegurate que tu componente
  adjunte el `className` enviado al nodo de DOM:

  ```jsx
  class MiComponente extends React.Component {
    render() {
      // Adjunta el `className` enviado al nodo de DOM
      return <div className={this.props.className} />;
    }
  }
  ```

  Si tienes algunos estilos preexistentes con una clase, puedes combinar la clase global con la
  enviada:

  ```jsx
  class MiComponente extends React.Component {
    render() {
      // Adjunta el `className` enviado al nodo de DOM
      return <div className={`alguna-clase-global ${this.props.className}`} />;
    }
  }
  ```

  ### Problemas con la especificidad

  Si aplicas una clase global junto a una clase de "styled-component", el resultado puede que no
  sea lo que est√°s esperando. Si una propiedad est√° definida en ambas clases con la misma
  especificidad, la √∫ltima es la que se aplicar√°.

  ```jsx
  // MiComponente.js
  const MiComponente = styled.div`background-color: green;`;

  // mi-componente.css
  .bg-rojo {
    background-color: red;
  }

  // Por alguna raz√≥n este componente a√∫n tendr√° el fondo color verde,
  // ¬°Incluso cuando est√°s tratando de sobreescribirlo con la clase "bg-rojo"!
  <MiComponente className="bg-rojo" />
  ```

  En el ejemplo de arriba, la clase del "styled-component" tiene precedencia sobre la clase global,
  ya que styled-components inyecta sus estilos durante ejecuci√≥n dentro del DOM al final del head.
  Por lo tanto, sus estilos ganan sobre otros.

  Ya que es dif√≠cil controlar donde tu CSS global es inyectado al DOM con herramientas como Webpack,
  la manera m√°s sencilla de subir la especificidad de tu clase global repitiendo el nombre de clase:

  ```css
  /* mi-componente.css */
  .bg-rojo.bg-rojo {
    background-color: red;
  }
  ```
mediaTemplates: |
  ## Media Templates

  Los "Media queries" son una herramienta indispensable cuando se desarrollan aplicaciones web
  responsivas.

  Este es un ejemplo muy simple. Muestra a un componente b√°sico cambiando su color de fondo, una
  vez que el ancho de la pantalla es menor al l√≠mite de `700px`.

  ```react
  const Content = styled.div`
    background: papayawhip;
    height: 3em;
    width: 3em;

    @media (max-width: 700px) {
      background: palevioletred;
    }
  `;

  render(
    <Content />
  );
  ```

  Ya que los "media queries" son largos y muchas veces repetidos a trav√©s de las aplicaciones, es
  √∫til crear un componente para ellos.

  Debido a la naturaleza funcional de JavaScript, puedes facilmente definir tu propio "template literal"
  para cambiar estilos dentro de "media queries". Reescribamos el √∫ltimo ejemplo para probar justo eso.

  ```react
  const sizes = {
    desktop: 992,
    tablet: 768,
    phone: 376
  }

  // Iterar a trav√©s de los tama√±os y crear un "media template"
  const media = Object.keys(sizes).reduce((acc, label) => {
    acc[label] = (...args) => css`
      @media (max-width: ${sizes[label] / 16}em) {
        ${css(...args)}
      }
    `

    return acc
  }, {})

  const Content = styled.div`
    height: 3em;
    width: 3em;
    background: papayawhip;

    /* Ahora tenemos nuestros m√©todos de media y podemos usarlos en vez de utilizarlos directamente */
    ${media.desktop`background: dodgerblue;`}
    ${media.tablet`background: mediumseagreen;`}
    ${media.phone`background: palevioletred;`}
  `;

  render(
    <Content />
  );
  ```
taggedTemplateLiterals: |
  ## Tagged Template Literals

  Las "tagged template literals" son una caracter√≠stica nueva en ES6. Te permiten definir reglas
  customizadas de interpolaci√≥n. Que es como somos capaces de crear "styled-components".

  Si no pasas interpolaciones, el primer argumento de tu funci√≥n, recibe un arreglo con la cadena en √©l.

  ```jsx
  // Estos son equivalentes:
  fn`una cadena aqu√≠`;
  fn([ 'una cadena aqu√≠' ]);
  ```

  Una vez que pases las interpolaciones, el arreglo contiene la cadena enviada, separada en las
  posiciones de las interpolaciones. El resto de los argumentos ser√°n las interpolaciones en √≥rden.

  ```jsx
  const aVar = 'buen';

  // √âstos son equivalentes:
  fn`este es un ${aVar} d√≠a`;
  fn([ 'este es un ', ' d√≠a' ], aVar);
  ```

  Esto es un poco engorroso para trabajar, pero significa que podemos recibir variables, funciones, o
  mixins (ayudante de `css`) en los "styled components" y se puede convertir a CSS puro.

  Si quieres aprender m√°s sobre "tagged template literals", revisa el art√≠culo de Max Stoiber:
  [The magic behind üíÖ styled-components](https://mxstbr.blog/2016/11/styled-components-magic-explained/)
serverSideRendering: |
  ## Renderizado del lado del servidor | v2

  styled-components soporta renderizado del lado del servidor de manera concurrente, con rehidrataci√≥n
  de hojas de estilo. La idea b√°sica es que cada vez que renderices tu aplicaci√≥n en el servidor, puedes
  crear un `ServerStyleSheet` y a√±adirlo a un "provider" en tu √°rbol de React, esto acepta estilos
  via el API de contexto.

  Esto no interfiere con los estilos globales. como por ejemplo `keyframes` o `injectGlobal` adem√°s
  te permite usar styled-components con el SSR de React DOM o incluso Rapscallion.

  El API b√°sico va de la siguiente manera:

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(sheet.collectStyles(<TuAplicacion />))
  const styleTags = sheet.getStyleTags() // o sheet.getStyleElement()
  ```

  El m√©todo `collectStyles` envuelve tu elemento en un proveedor. Opcionalmente puedes usar el
  proveedor `StyleSheetManager` directamente, en vez de √©ste m√©todo. Tan s√≥lo asegurate de no usarlo
  en el lado del cliente.

  ```jsx
  import { renderToString } from 'react-dom/server'
  import { ServerStyleSheet, StyleSheetManager } from 'styled-components'

  const sheet = new ServerStyleSheet()
  const html = renderToString(
    <StyleSheetManager sheet={sheet.instance}>
      <TuAplicacion />
    </StyleSheetManager>
  )

  const styleTags = sheet.getStyleTags() // o sheet.getStyleElement()
  ```

  `sheet.getStyleTags()` retorna una cadena de m√∫ltiples etiquetas `<style>`.
  Necesitas tomar esto en cuenta cuando a√±adas la cadena de CSS a tu salida de HTML.

  Alternativamente la instancia de `ServerStyleSheet` tambi√©n tiene un m√©todo `getStyleElement()`
  que retorna un arreglo de elementos de React.

  ### Next.js

  En Next.js, necesitar√°s estructurar tu archivo `_document.js` de manera diferente, que la que se
  provee en su ejemplo de su repositorio para la versi√≥n 1.

  ```jsx
  import Document, { Head, Main, NextScript } from 'next/document'
  import { ServerStyleSheet } from 'styled-components'

  export default class MyDocument extends Document {
    static getInitialProps ({ renderPage }) {
      const sheet = new ServerStyleSheet()
      const page = renderPage(App => props => sheet.collectStyles(<App {...props} />))
      const styleTags = sheet.getStyleElement()
      return {
        ...page,
        styleTags
      }
    }

    render() {
      return (
        <html>
          <Head>
            {/* ... */}

            {this.props.styleTags}
          </Head>
          <body>
            <Main />
            <NextScript />
          </body>
        </html>
      )
    }
  }
  ```

  Necesitar√°s usar `babel-plugin-styled-components` para que esto funcione.
  M√°s detalles [aqu√≠](https://www.npmjs.com/package/babel-plugin-styled-components)

  Refi√©rete a [nuestro ejemplo](https://github.com/zeit/next.js/tree/master/examples/with-styled-components)
  en el repositorio de Next.js de un ejemplo de uso actualizado.
